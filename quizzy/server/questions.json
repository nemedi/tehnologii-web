{
	"Programare în C/C++":
	{
		"Tipuri fundamentale de date și constante în C":
		{
		  "Cum afectează platforma (arhitectura sistemului) dimensiunea tipurilor fundamentale de date în C?": "Dimensiunea tipurilor fundamentale de date, cum ar fi int, long sau pointerii, poate varia în funcție de arhitectura sistemului (de exemplu, 32-bit vs 64-bit). Pe un sistem pe 32 de biți, un int are de obicei 4 octeți, iar pe un sistem pe 64 de biți, poate fi la fel, însă pointerii sunt de obicei de 8 octeți. Standardul C specifică doar dimensiunea minimă, nu una fixă.",
		  "Ce probleme pot apărea dacă nu se ține cont de intervalul de valori al unui tip de date în C?": "Dacă nu se ține cont de intervalul de valori (de exemplu, la int sau char), pot apărea depășiri (overflow) sau interpretări greșite ale valorilor (signed vs unsigned). De exemplu, un overflow într-un int semnat poate duce la rezultate imprevizibile și la bug-uri greu de depistat.",
		  "Care este diferența practică între folosirea #define și const pentru definirea constantelor în C?": "const definește o constantă cu tip, verificată de compilator, ceea ce ajută la debugging și verificare statică. #define este doar o substituție textuală efectuată de preprocesor, fără verificări de tip și fără ocuparea de memorie, dar poate duce la erori subtile deoarece nu respectă regulile de tip din C.",
		  "Cum pot fi utilizate modificatorii de tip (signed, unsigned, short, long) pentru a controla spațiul de memorie și gama de valori?": "Modificatorii permit controlul precis asupra intervalului de valori și asupra memoriei consumate. De exemplu, unsigned int dublează gama pozitivă, short int reduce dimensiunea la 2 octeți, iar long long int permite valori foarte mari. Alegerea corectă poate optimiza memoria și performanța aplicației.",
		  "Cum se pot defini constante pentru valori de tip float sau double folosind #define și care sunt riscurile?": "Se pot defini valori reale astfel: #define PI 3.1415926535. Însă, fără paranteze, există riscul de evaluare incorectă în expresii compuse. De exemplu, #define AREA(x) PI * x * x poate produce rezultate greșite dacă nu se pun paranteze adecvate.",
		  "Ce rol joacă tipul void în definirea funcțiilor și a pointerilor în C?": "Tipul void este folosit pentru a indica faptul că o funcție nu returnează valoare (void func()) sau pentru a declara pointeri generici (void*), care pot fi convertiți ulterior în orice alt tip de pointer. Acesta oferă flexibilitate și permite implementarea unor funcții generice (ex: malloc returnează void*).",
		  "Cum se asigură portabilitatea codului C în ceea ce privește tipurile de date fundamentale?": "Pentru portabilitate, se recomandă folosirea tipurilor standard definite în stdint.h, cum ar fi int32_t sau uint64_t, deoarece acestea au dimensiuni bine definite pe toate platformele. De asemenea, evitarea presupunerilor implicite despre dimensiunea tipurilor clasice (int, long) ajută la portarea codului.",
		  "Cum pot fi folosite constantele pentru a proteja date critice în memorie?": "Constantele declarate cu const indică compilatorului și celorlalți programatori că valoarea nu trebuie modificată. În plus, compilatorul poate optimiza plasarea constantelor în secțiuni de memorie read-only, prevenind modificări accidentale la rulare și sporind siguranța aplicației.",
		  "Cum se pot combina tipurile fundamentale și directivele de preprocesare pentru a crea cod mai clar și mai flexibil?": "Prin combinarea typedef, #define și const, se pot crea tipuri personalizate și constante simbolice ușor de întreținut. De exemplu, typedef unsigned long ulong; și #define BUFFER_SIZE 1024 pot face codul mai lizibil și mai portabil. De asemenea, se pot folosi macros cu parametri pentru funcționalitate repetitivă.",
		  "Ce impact are alegerea tipului de date asupra performanței și consumului de memorie într-o aplicație C?": "Alegerea tipului de date influențează direct atât viteza de execuție, cât și consumul de memorie. Tipurile mai mici (ex: char sau short) reduc memoria dar pot introduce penalități de aliniere pe unele arhitecturi. Tipurile mai mari (ex: double) oferă precizie mai mare, dar ocupă mai multă memorie și pot încetini procesarea pe unele procesoare. Alegerea corectă trebuie făcută în funcție de cerințele aplicației."
		},
		"Specificatorul de format":
		{
		  "Cum funcționează specificatorii de format în funcțiile printf și scanf în C?": "Specificatorii de format definesc tipul și modul de afișare sau citire al valorilor în funcțiile printf și scanf. De exemplu, %d pentru int, %f pentru float, %s pentru șiruri de caractere. Ei informează funcția cum să interpreteze argumentele variadice transmise, evitând interpretările greșite.",
		  "Ce probleme pot apărea dacă se folosește un specificator de format nepotrivit în printf sau scanf?": "Dacă specificatorul nu corespunde tipului argumentului, pot apărea comportamente imprevizibile, cum ar fi afișarea de valori incorecte sau chiar coruperea stivei. De exemplu, folosirea %f pentru un int poate cauza afișarea unor valori aleatorii.",
		  "Cum poți controla numărul de zecimale afișat pentru tipurile float și double?": "Prin utilizarea specificatorului de precizie în forma %.nf, unde n indică numărul de zecimale. De exemplu, printf(\"%.2f\", 3.1415) va afișa 3.14. Acest mecanism permite controlul precis asupra formatului numeric afișat.",
		  "Care este diferența dintre %f și %lf în funcțiile printf și scanf?": "În printf, atât %f cât și %lf sunt echivalente și se folosesc pentru float promovat la double (deoarece argumentele float se promovează la double în liste variadice). În scanf, %f este pentru float (via pointer la float), iar %lf pentru double (pointer la double).",
		  "Cum se pot formata valorile pentru a ocupa o lățime fixă în printf?": "Se poate specifica o lățime minimă printr-un număr între procent și specificator: %5d va rezerva minim 5 caractere pentru un int. Dacă valoarea are mai puține cifre, se completează cu spații la stânga (implicit).",
		  "Cum se pot alinia valorile la stânga sau la dreapta folosind specificatorii de format?": "Folosind semnul minus în fața lățimii: %-5d aliniază la stânga într-un câmp de minim 5 caractere. Fără minus, alinierea este implicit la dreapta.",
		  "Cum se pot afișa valori hexazecimale și care este diferența între %x și %X?": "Se folosește %x pentru a afișa valorile hexazecimale cu litere mici (a–f) și %X pentru litere mari (A–F). De exemplu, printf(\"%x\", 255) afișează ff, iar printf(\"%X\", 255) afișează FF.",
		  "Cum se pot afișa pointerii folosind specificatori de format?": "Se folosește specificatorul %p, care afișează adresa pointerului în format hexazecimal, dependent de platformă. De exemplu, printf(\"%p\", ptr) va afișa adresa la care pointează ptr.",
		  "Ce rol are specificatorul * în controlul dinamic al lățimii sau preciziei în printf?": "Semnul * permite ca lățimea câmpului sau precizia să fie specificate prin argumente suplimentare. De exemplu, printf(\"%*.*f\", 8, 3, 3.1415) va afișa numărul 3.142 într-un câmp de minim 8 caractere cu 3 zecimale.",
		  "Cum pot fi combinate mai mulți specificatori pentru un control detaliat asupra formatării?": "Se pot combina specificatori pentru semn, lățime, precizie și aliniere. De exemplu, %+08.2f în printf va afișa un număr în format zecimal cu semn explicit (+ sau -), completând cu zerouri la stânga dacă e nevoie, pe minim 8 caractere și cu 2 zecimale. Această combinație oferă un control foarte precis asupra aspectului final al textului."
		},
		"Clase de memorie":
		{
		  "De ce modificarea unei variabile alocată register de către un fir de execuție nu este văzută de alt fir de execuție al aceluiași program?": "Fiecare fir are stiva lui proprie și propriul context procesor care este salvat la întreruperea firului și restaurat la reluarea execuției lui.",
		  "Care este diferența între durata de viață a unei variabile allocate pe stivă (stack) și una allocate pe heap?": "Variabilele allocate pe stivă au durată de viață legată de apelul funcției: sunt create la intrare și distruse la ieșire. Variabilele allocate pe heap persistă până când sunt eliberate explicit de programator cu free(). Heap-ul permite o durată de viață flexibilă, dar necesită gestionare manuală.",
		  "Cum influențează utilizarea keyword-ului static la nivel de fișier vizibilitatea variabilelor?": "Keyword-ul static restricționează vizibilitatea variabilei sau funcției doar la fișierul sursă unde este definită (translation unit). Astfel, alte fișiere care includ headerul sau încearcă să folosească variabila nu vor avea acces la ea.",
		  "De ce este periculoasă utilizarea excesivă a variabilelor globale în proiecte mari?": "Variabilele globale pot fi accesate și modificate oriunde, ceea ce duce la efecte laterale greu de controlat, crește riscul conflictelor la linking, face codul greu de întreținut și limitează modularitatea.",
		  "Cum pot fi utilizate variabilele register pentru optimizarea performanței, și care sunt limitările lor?": "Variabilele register sugerează compilatorului să le stocheze în registrele procesorului pentru acces rapid. Totuși, compilatorul poate ignora sugestia, iar adresa lor nu poate fi obținută (operatorul & este interzis). Sunt utile doar pentru variabile accesate frecvent în bucle strânse.",
		  "Care este scopul segmentului BSS și cum afectează el variabilele statice neinițializate?": "Segmentul BSS conține variabile globale și statice neinițializate explicit. Sistemul le inițializează automat la zero înainte de execuția programului, reducând astfel dimensiunea binarului pe disc (deoarece nu se salvează valori explicite).",
		  "Ce impact are utilizarea excesivă a variabilelor auto locale asupra consumului de stivă?": "Folosirea variabilelor auto (locale) alocate pe stivă în cantitate mare (ex: tablouri mari) poate duce la depășirea stivei (stack overflow), ceea ce provoacă erori de execuție sau crash-uri. Este important să se evite alocarea locală masivă și să se folosească heap-ul când este necesar.",
		  "Cum pot variabilele statice la nivel de funcție să contribuie la implementarea unui singleton?": "O variabilă statică locală în interiorul unei funcții poate fi folosită pentru a stoca instanța unică a unui obiect (singleton). Deoarece păstrează valoarea între apeluri și nu poate fi accesată din exterior, garantează existența unei singure instanțe controlate.",
		  "Cum diferă specificatorul extern față de static în controlul vizibilității variabilelor globale?": "extern indică faptul că variabila este definită în alt fișier și permite accesul global la ea. static restricționează accesul doar la fișierul în care este definită, prevenind conflictele externe și îmbunătățind encapsularea.",
		  "Ce se întâmplă cu variabilele globale și statice după terminarea execuției programului?": "Variabilele globale și cele statice există pe tot parcursul execuției programului și sunt eliberate automat de sistem la terminarea programului. Nu este nevoie (și nici posibil) să fie eliberate explicit de către programator."
		},
		"Clase de operatori":
		{
		  "Cum pot influența operatorii de incrementare și decrementare ordinea evaluării expresiilor complexe în C?": "Operatorii ++ și -- pot avea efecte secundare care modifică valoarea operandului în timpul evaluării. În expresii complexe, ordinea evaluării sub-expresiilor nu este strict definită în C, ceea ce poate duce la rezultate neașteptate sau nedefinite. De aceea, astfel de expresii ar trebui evitate sau scrise clar, pe pași separați.",
		  "Care este diferența semantică dintre operatorii logici && și operatorul binar &?": "Operatorul && evaluează expresiile logic și aplică evaluare scurt-circuit (short-circuit): dacă prima expresie este falsă, a doua nu mai este evaluată. Operatorul & este un operator binar care efectuează o operație bit cu bit și evaluează întotdeauna ambii operanzi.",
		  "Cum funcționează operatorul condițional (ternar) și ce avantaje oferă comparativ cu if-else?": "Operatorul ternar `? :` permite evaluarea expresiilor condiționale într-o formă compactă: `cond ? expr_true : expr_false`. Avantajul este scrierea mai concisă și posibilitatea utilizării direct în expresii, însă poate reduce lizibilitatea dacă este folosit excesiv sau în expresii complexe.",
		  "Ce probleme pot apărea la utilizarea operatorilor de atribuție compuși în expresii cu efecte secundare?": "Operatorii de atribuție compuși (ex: +=, -=, *=) pot interacționa cu efectele secundare (precum incrementarea operandului în același timp). Dacă operandul apare de mai multe ori în expresie, ordinea exactă a evaluării poate genera comportament nedefinit.",
		  "Cum diferă operatorii de comparație față de cei logici în ceea ce privește valoarea rezultată?": "Operatorii de comparație (ex: ==, !=, <, >) produc o valoare 0 (fals) sau 1 (adevărat), însă operatorii logici (&&, ||) combină rezultatele mai multor expresii și folosesc evaluarea scurt-circuit. Ambii returnează valori întregi, dar semantica de evaluare și ordinea pot diferi.",
		  "Cum pot fi folosiți operatorii de accesare a memoriei (* și &) în manipularea pointerilor?": "Operatorul * dereferențiază un pointer, accesând valoarea către care pointează, în timp ce operatorul & obține adresa unei variabile. Împreună, permit manipularea directă a memoriei, implementarea listelor înlănțuite, alocarea dinamică și trecerea argumentelor prin referință.",
		  "Ce diferență există între operatorul de subscript [] și aritmetica pointerilor?": "Operatorul [] este definit ca *(a + i), unde a este pointer și i este indice. Astfel, expresiile a[i] și *(a + i) sunt echivalente, ambele bazându-se pe aritmetica pointerilor pentru a calcula adresa efectivă a elementului accesat.",
		  "Cum se comportă operatorul virgula (,) în evaluarea expresiilor și când ar trebui evitat?": "Operatorul virgulă evaluează expresiile de la stânga la dreapta, returnând valoarea ultimei expresii. Este util în for-uri sau expresii concise, dar reduce lizibilitatea și poate fi greu de întreținut. De obicei se recomandă evitarea în expresii complexe.",
		  "Ce se întâmplă când combinăm operatorii de shifting (<<, >>) cu tipuri semnate și nesemnate?": "Pentru tipurile semnate, shifting-ul la dreapta (>>) poate efectua shift aritmetic (păstrează semnul), în timp ce la tipuri nesemnate se face shift logic (se completează cu 0). Utilizarea necorespunzătoare poate duce la rezultate greșite, mai ales în manipularea biților.",
		  "Cum poate fi supraîncărcat comportamentul operatorilor în C?": "În C, nu există suport direct pentru supraîncărcarea operatorilor (spre deosebire de C++). Comportamentul operatorilor nu poate fi redefinit pentru tipuri definite de utilizator; însă pot fi definite funcții care simulează efectul, dar cu sintaxă explicită și mai puțin elegantă."
		},
		"Structuri de control":
		{
		  "Cum se pot combina structurile alternative și repetitive într-un program pentru a rezolva o problemă complexă?": "Structurile alternative (if, if-else, switch) permit luarea deciziilor pe baza unor condiții, iar structurile repetitive (while, for, do-while) permit repetarea unui bloc de cod. Într-un program complex, acestea se combină pentru a permite verificarea condițiilor și repetarea operațiilor până la îndeplinirea unui criteriu, de exemplu, într-un algoritm de căutare sau procesare iterativă a datelor.",
		  "Care sunt principalele diferențe între structurile repetitive while, do-while și for în C și când ar trebui folosite fiecare?": "While verifică condiția înainte de a executa blocul, deci dacă condiția e falsă de la început, nu se execută deloc. Do-while execută blocul cel puțin o dată, verificând condiția la final. For este recomandată când numărul de iterații este cunoscut sau derivabil. Alegerea între ele depinde de logica problemei: while pentru bucle nedeterminate, do-while pentru execuție obligatorie minim o dată, for pentru iterații finite și controlate.",
		  "Ce probleme pot apărea dacă o structură repetitivă nu are o condiție de oprire corect definită în C?": "Dacă o structură repetitivă nu are o condiție de oprire corectă, poate apărea o buclă infinită, ceea ce duce la blocarea programului sau consumarea excesivă a resurselor (CPU). De asemenea, poate produce rezultate incorecte sau coruperea datelor, în funcție de operațiile din interiorul buclei.",
		  "Cum se poate utiliza o structură alternativă switch pentru a simplifica verificarea mai multor condiții?": "Switch permite testarea valorii unei expresii întregi sau a unui caracter, comparând-o cu mai multe cazuri (case). Este mai lizibil și mai eficient decât mai multe if-else consecutive. De exemplu, pentru meniuri de opțiuni sau selectarea acțiunii în funcție de o valoare numerică, switch reduce codul redundant și clarifică logica.",
		  "Cum se pot combina structurile repetitive cu cele alternative pentru a implementa un meniu interactiv în C?": "Se poate folosi o buclă while pentru a menține activ meniul până când utilizatorul alege să iasă. În interiorul buclei, se folosește un switch sau if-else pentru a executa acțiunea corespunzătoare opțiunii alese. Astfel, utilizatorul poate repeta alegerea opțiunilor până decide să închidă aplicația.",
		  "Cum se pot evita erorile legate de validarea datelor introduse de utilizator în structuri alternative și repetitive?": "Se pot folosi verificări stricte ale condițiilor înainte de a intra în logică. De exemplu, dacă se așteaptă un număr pozitiv, se verifică cu if, iar dacă nu este corect, se cere reintroducerea datelor folosind o buclă repetitivă (while sau do-while). Această abordare crește robustetea și previne erorile de execuție sau comportamentele neașteptate.",
		  "Care sunt avantajele utilizării structurii for în loc de while în cazul parcurgerii unor tablouri?": "For oferă o structură mai compactă și clară pentru parcurgerea tablourilor, deoarece contorul, condiția și incrementarea sunt toate grupate într-o singură linie, ușurând citirea și întreținerea codului. În while, incrementarea contorului și condiția sunt separate, ceea ce poate duce la erori mai ușor.",
		  "Cum se pot folosi structurile repetitive pentru a implementa algoritmi iterativi precum căutarea secvențială sau sortarea prin selecție?": "Pentru căutarea secvențială, se folosește o buclă for sau while pentru a parcurge elementele până când se găsește elementul căutat sau se termină lista. Pentru sortarea prin selecție, se folosesc două bucle for imbricate: prima pentru a selecta poziția curentă, a doua pentru a căuta minimul în restul listei și a face swap. Astfel, structurile repetitive sunt fundamentale în implementarea acestor algoritmi.",
		  "Ce rol joacă structurile alternative în asigurarea corectitudinii rezultatelor unui algoritm repetitiv?": "Structurile alternative sunt esențiale pentru a verifica condiții pe parcursul execuției repetate. Ele pot decide dacă se continuă sau nu o anumită acțiune, pot valida datele sau pot selecta pași diferiți în funcție de situație. Astfel, ele controlează fluxul algoritmului și asigură obținerea rezultatelor corecte în funcție de cazurile particulare întâlnite.",
		  "De câte ori afișează următorul for și de ce: for (float f = 0.0; f != 1.0; f += 0.1) printf(\"%f\", f); ?": "De o infinitate de ori pentru că 0.1 este număr cu perioadă în binar și se trunchează, ceea ce face ca de 10 ori valoarea să nu fie egală cu 1.0."
		},
		"Pointeri și aritmetica de pointeri, masive uni- și multi-dimensionale":
		{
		  "Ce este un pointer în C și cum se diferențiază față de o variabilă obișnuită?": "Un pointer este o variabilă care stochează adresa de memorie a altei variabile. Spre deosebire de o variabilă obișnuită care conține o valoare directă (ex: un int = 5), pointerul conține o referință către locația unde se află acea valoare. Prin dereferențiere (operatorul *), se poate accesa valoarea la care pointează.",
		  "Cum se realizează aritmetica pointerilor și care este rolul ei când lucrăm cu tablouri?": "Aritmetica pointerilor presupune adunarea sau scăderea unui număr întreg la un pointer, sau scăderea a doi pointeri. La incrementarea unui pointer, acesta avansează cu dimensiunea tipului spre care pointează (ex: p++ la un int avansează cu sizeof(int)). În cazul tablourilor, pointerii pot fi folosiți pentru a parcurge elementele fără a folosi indecși expliciți.",
		  "Cum se poate accesa un element dintr-un tablou unidimensional folosind pointeri în loc de operatorul de indexare?": "Elementul array[i] poate fi accesat și ca *(array + i). Această formulă se bazează pe faptul că numele tabloului este un pointer la primul element și aritmetica pointerilor calculează adresa corectă a elementului dorit.",
		  "Care sunt avantajele și dezavantajele folosirii pointerilor pentru a manipula tablouri unidimensionale?": "Avantajele includ performanța crescută prin acces direct la memorie și flexibilitatea în manipularea secvențelor de date. Dezavantajele sunt riscul de erori greu de depistat (ex: acces în afara limitelor), scurgeri de memorie, și dificultăți în înțelegere și depanare pentru programatorii începători.",
		  "Cum sunt reprezentate și accesate tablourile bidimensionale în C folosind pointeri?": "Un tablou bidimensional int a[3][4] este reprezentat în memorie ca un bloc continuu de 3*4 elemente. Pentru a accesa a[i][j] cu pointeri, se poate scrie *(*(a + i) + j). Aritmetica pointerilor calculează offset-ul corect pornind de la baza tabloului.",
		  "Cum putem aloca dinamic un tablou bidimensional folosind pointeri?": "Se poate aloca un tablou bidimensional ca un tablou de pointeri: întâi se alocă un pointer la pointeri (ex: int **a), apoi se alocă fiecare rând individual folosind malloc. Alternativ, se poate aloca un bloc unic mare (int *block = malloc(rows * cols * sizeof(int))) și apoi se calculează manual offset-ul fiecărui element.",
		  "Ce se întâmplă dacă se dereferențiază un pointer neinițializat sau NULL?": "Dereferențierea unui pointer neinițializat sau NULL duce la un comportament nedefinit, care poate cauza crash-ul programului, coruperea memoriei sau alte erori severe. De aceea, se recomandă întotdeauna inițializarea pointerilor și verificarea lor înainte de dereferențiere.",
		  "Cum se pot transmite tablouri unidimensionale și bidimensionale ca parametri către funcții folosind pointeri?": "Pentru tablouri unidimensionale, funcția primește un pointer la primul element (ex: void f(int *v)). Pentru tablouri bidimensionale, se pot transmite ca pointer la primul element și se specifică numărul de coloane (ex: void f(int a[][COLS]) sau void f(int (*a)[COLS])). În cazul alocării dinamice, se poate transmite int **a împreună cu dimensiunile.",
		  "Cum pot fi utilizate pointerii pentru a simula tablouri dinamice și care sunt avantajele acestei metode?": "Pointerii pot fi folosiți cu malloc pentru a aloca tablouri de dimensiune variabilă la execuție. Avantajele sunt flexibilitatea (dimensiunea poate fi stabilită la rulare) și economia de memorie (se alocă exact cât este necesar). Dezavantajele sunt complexitatea mai mare și riscul de scurgeri de memorie dacă nu se eliberează corect cu free.",
		  "Ce rol joacă pointerii la pointeri (double pointers) în manipularea tablourilor multidimensionale sau în implementarea funcțiilor care modifică adrese?": "Pointerii la pointeri permit manipularea indirectă a adreselor, permițând alocarea și modificarea structurilor complexe precum tablouri 2D. De asemenea, sunt esențiali când se dorește modificarea adresei unui pointer în interiorul unei funcții, deoarece se poate transmite adresa pointerului inițial (ex: funcții care alocă memorie și returnează adresa prin argument)."
		},
		"Masive de pointeri și pointeri la masive":
		{
		  "Ce este un masiv de pointeri în C și în ce situații este util?": "Un masiv de pointeri este un tablou în care fiecare element este un pointer (de exemplu, char *v[10]). Este util atunci când trebuie să gestionăm mai multe șiruri de caractere, blocuri de memorie alocate dinamic, sau când avem nevoie de flexibilitate în referințele către date care pot avea dimensiuni diferite.",
		  "Cum se inițializează un masiv de pointeri la șiruri de caractere și cum se accesează fiecare șir?": "Se poate inițializa astfel: char *v[] = {\"Ana\", \"are\", \"mere\"};. Accesarea unui șir se face cu v[i], iar caracterul j din șirul i se accesează cu v[i][j]. Fiecare v[i] este un pointer către primul caracter al șirului corespunzător.",
		  "Care sunt avantajele folosirii masivelor de pointeri pentru stocarea șirurilor în comparație cu un tablou bidimensional de caractere?": "Avantajele masivelor de pointeri includ posibilitatea de a avea șiruri de lungimi variabile și reducerea risipei de memorie. La tablourile bidimensionale trebuie stabilită o lungime fixă maximă, ceea ce duce la alocare excesivă. Masivele de pointeri permit alocarea fiecărui șir exact cât este necesar.",
		  "Ce este un pointer la masiv și cum se declară corect în C?": "Un pointer la masiv este un pointer care pointează la un întreg tablou (ex: int (*p)[5]). Spre deosebire de un pointer la un element individual, acesta păstrează informația despre dimensiunea blocului de date și permite manipularea unui tablou întreg ca o unitate.",
		  "Cum se diferențiază un masiv de pointeri de un pointer la masiv din punct de vedere al sintaxei și al comportamentului?": "Un masiv de pointeri (ex: int *v[10]) este un tablou unde fiecare element este un pointer la int și poate pointa la locații diferite. Un pointer la masiv (ex: int (*p)[10]) este un pointer care referă un bloc întreg de 10 elemente consecutive. Sintactic, parantezele sunt importante pentru a clarifica asocierile.",
		  "Cum pot fi utilizate masivele de pointeri pentru a implementa un vector de funcții și care este utilitatea acestei abordări?": "Se poate defini un masiv de pointeri la funcții, ex: int (*f[3])(int, int). Această tehnică permite stocarea adreselor mai multor funcții, astfel încât să le putem apela dinamic, în funcție de context. Este extrem de utilă la implementarea meniurilor interactive, interpretoarelor de comenzi și la reducerea codului redundant.",
		  "Care sunt riscurile folosirii masivelor de pointeri și cum pot fi evitate erorile?": "Riscurile includ accesarea pointerilor neinițializați, dereferențierea adreselor invalide și scurgerile de memorie. Pentru prevenirea erorilor, se recomandă inițializarea pointerilor la NULL, verificarea înainte de accesare și eliberarea corectă a memoriei alocate dinamic folosind free.",
		  "Cum se pot parcurge și modifica elementele unui masiv de pointeri la șiruri de caractere?": "Masivul se parcurge cu un index (ex: for (i = 0; i < n; i++)), iar fiecare șir se poate modifica fie direct, fie prin realocare. Se poate înlocui un șir prin atribuirea unui nou pointer sau se pot modifica caractere individuale prin acces direct la v[i][j].",
		  "Cum se transmite un pointer la masiv ca argument către o funcție și de ce este această metodă utilă?": "Se transmite astfel: void f(int (*p)[5]). Această abordare permite accesarea și modificarea unui tablou întreg de 5 elemente ca un bloc, fără a copia datele. Este utilă mai ales pentru accesarea rândurilor individuale în tablourile bidimensionale sau pentru manipularea unor secțiuni fixe de memorie.",
		  "Cum se poate combina un masiv de pointeri cu alocarea dinamică pentru a crea structuri flexibile de tip matrice cu rânduri de lungimi variabile?": "Se definește un masiv de pointeri (ex: int *a[10]), iar fiecare a[i] se alocă separat cu malloc, având dimensiuni diferite dacă este necesar. În acest fel, putem construi matrice neregulate (jagged arrays), unde fiecare rând are un număr diferit de coloane, ceea ce conferă flexibilitate și eficiență în utilizarea memoriei."
		},
		"Variabile și constante de tip caracter, șir de caractere, pointeri la caracter":
		{
		  "Ce diferență există între o variabilă de tip char și un șir de caractere în C?": "O variabilă de tip char poate stoca un singur caracter (ex: char c = 'A'), în timp ce un șir de caractere (char s[]) este o succesiune de caractere terminată cu caracterul nul '\\0'. Șirurile sunt reprezentate în C ca tablouri de char și sunt folosite pentru a reprezenta cuvinte sau texte.",
		  "Cum se definește o constantă de tip caracter și una de tip șir de caractere în C?": "O constantă de tip caracter se definește între apostrofuri, ex: 'A'. O constantă de tip șir se definește între ghilimele duble, ex: \"Salut\". În cazul șirurilor, caracterul nul '\\0' este adăugat automat la final pentru a marca terminarea șirului.",
		  "Care sunt avantajele utilizării pointerilor la caracter pentru manipularea șirurilor?": "Pointerii la caracter permit navigarea rapidă prin șiruri, trecerea de la un caracter la altul prin aritmetică de pointeri, modificarea directă a conținutului și transmiterea eficientă a șirurilor între funcții (se transmite doar adresa, nu tot tabloul).",
		  "Cum poți copia un șir de caractere folosind pointeri în locul funcției strcpy?": "Se poate parcurge șirul sursă cu un pointer, copierea făcându-se caracter cu caracter: while ((*dest++ = *src++) != '\\0');. Această metodă copiază inclusiv caracterul nul final și nu necesită librăria string.h.",
		  "Cum se comportă un șir de caractere declarat ca char * versus char []?": "char *s definește un pointer la caracter, care poate fi modificat să pointeze la alt șir. char s[] alocă spațiu fix și copiază șirul literal în acel spațiu, deci adresa rămâne fixă. Dacă încerci să modifici un literal string prin char *s = \"abc\", apare comportament nedefinit deoarece literalul este constant.",
		  "Ce se întâmplă când transmiți un șir de caractere ca argument într-o funcție?": "În C, un șir de caractere transmis ca argument devine automat un pointer la primul caracter. Astfel, modificările făcute asupra șirului în funcție vor afecta și variabila originală, deoarece ambele referă aceeași zonă de memorie.",
		  "Cum poți calcula lungimea unui șir de caractere folosind pointeri, fără strlen?": "Se parcurge șirul cu un pointer până la întâlnirea caracterului nul: int len = 0; while (*p++) len++;. Astfel se numără caracterele efective din șir, fără a folosi funcții externe.",
		  "Cum poți concatena două șiruri folosind pointeri?": "Se mută pointerul dest la sfârșitul primului șir (înainte de '\\0'), apoi se copiază caracterele din sursă până la caracterul nul: while (*dest) dest++; while ((*dest++ = *src++) != '\\0');. Astfel se adaugă șirul sursă la finalul celui destinație.",
		  "Cum se pot crea șiruri de caractere constante care să nu poată fi modificate?": "Se declară pointerul ca fiind const: const char *s = \"Text\";. Astfel, orice încercare de a modifica conținutul la care pointează s va fi semnalată de compilator și va preveni modificările accidentale.",
		  "Ce riscuri există atunci când lucrezi cu pointeri la șiruri de caractere și cum pot fi prevenite?": "Riscurile includ depășirea limitelor (buffer overflow), modificarea memoriei constante, scurgerile de memorie sau accesarea unor pointeri nevalizi. Pentru prevenire, se verifică limitele, se folosesc funcții sigure (strncpy, snprintf), se inițializează pointerii și se evită modificarea string-urilor constante."
		},
		"Funcții de intrare / ieșire pentru caractere / șiruri de caractere":
		{
		  "Care este diferența între funcțiile getchar și getc și când ar trebui să le folosim?": "getchar citește un caracter de la stdin și este o versiune simplificată a getc. Funcția getc poate fi folosită pentru orice flux de fișier, ex: getc(fptr). Dacă citești doar de la tastatură, getchar este suficient, dar pentru fișiere se preferă getc.",
		  "Cum funcționează funcția gets și de ce este considerată nesigură?": "Funcția gets citește un șir de la stdin până la un newline, dar nu verifică dimensiunea bufferului, ceea ce duce la posibilitatea unui buffer overflow. Din acest motiv, gets a fost eliminată din standardul C11 și se recomandă folosirea fgets.",
		  "Cum se folosește fgets pentru a citi un șir de caractere și care sunt avantajele acesteia?": "fgets citește maxim n-1 caractere și adaugă '\\0' automat la final. Exemplu: fgets(buf, 100, stdin). Principalul avantaj este că se evită buffer overflow și se poate controla exact câte caractere se citesc.",
		  "Cum se scrie un șir de caractere la ieșire folosind puts și ce adaugă această funcție în plus?": "Funcția puts scrie un șir la stdout și adaugă automat un caracter newline ('\\n') la final. Este mai simplă decât printf dacă nu ai nevoie de formatare suplimentară.",
		  "Care este diferența între putchar și fputc și când se preferă una sau alta?": "putchar scrie un caracter la stdout, ex: putchar('A'). fputc permite specificarea fluxului (ex: fputc('A', fptr)), deci este mai flexibilă când vrei să scrii în fișiere sau alte fluxuri.",
		  "Cum poți folosi scanf pentru a citi un șir de caractere și care sunt riscurile?": "scanf cu specificatorul %s citește un șir până la primul spațiu. Riscurile principale sunt buffer overflow dacă nu se limitează lungimea, ex: scanf(\"%99s\", str). Este recomandat să se specifice întotdeauna lungimea maximă pentru a evita suprascrieri.",
		  "Cum poți elimina newline-ul rămas în buffer după o citire cu fgets?": "După fgets, dacă ultimul caracter citit este '\\n', se poate înlocui: if (strchr(buf, '\\n')) *strchr(buf, '\\n') = '\\0';. Astfel, șirul rămâne curat fără newline final.",
		  "Cum poți citi un caracter fără a aștepta Enter, similar cu getch din alte limbaje?": "Standardul C nu definește getch. În Windows, se poate folosi _getch din conio.h, iar în Linux se poate manipula terminalul (ex: folosind termios). Aceste metode permit citirea caracterului imediat, fără a cere Enter.",
		  "Cum poți scrie un șir de caractere într-un fișier folosind fprintf și care sunt avantajele?": "fprintf permite formatarea șirurilor și scrierea directă în fișiere: fprintf(fptr, \"%s %d\\n\", str, nr). Avantajul este flexibilitatea mare la format și posibilitatea de a scrie direct în fișiere deschise cu fopen.",
		  "Cum pot fi combinate funcțiile de intrare/ieșire pentru a implementa un mic editor de linii în C?": "Se pot folosi fgets pentru a citi fiecare linie, fputs sau fprintf pentru a salva liniile într-un fișier, putchar și getchar pentru navigare caracter cu caracter, și diverse combinații pentru a permite editarea locală. Astfel se poate construi un editor simplu, controlat manual, bazat pe fluxurile standard."
		},
		"Funcții pentru prelucrarea șirurilor de caractere":
		{
		  "Care este rolul funcției strcpy și ce riscuri implică utilizarea ei?": "Funcția strcpy copiază un șir sursă în alt șir destinație, inclusiv caracterul nul '\\0'. Riscul principal este că nu verifică dimensiunea destinației, ceea ce poate duce la buffer overflow. De aceea, se recomandă folosirea strncpy sau alte funcții sigure.",
		  "Cum funcționează funcția strcat și ce condiții trebuie îndeplinite pentru ca aceasta să fie sigură?": "strcat concatenează un șir sursă la finalul unui șir destinație deja existent. Este necesar ca destinația să aibă spațiu suficient pentru a stoca rezultatul final, altfel pot apărea suprascrieri de memorie și comportament nedefinit.",
		  "Cum poți compara două șiruri de caractere folosind strcmp și cum interpretezi rezultatul?": "strcmp compară lexicografic două șiruri. Returnează 0 dacă sunt egale, un număr negativ dacă primul șir este mai mic și un număr pozitiv dacă primul șir este mai mare. Este important să eviți să compari șiruri direct cu == deoarece ar compara adresele, nu conținutul.",
		  "Care este diferența între strncpy și strcpy și când ar trebui să folosim strncpy?": "strncpy copiază maximum n caractere și umple cu '\\0' dacă sursa este mai scurtă. Este utilă pentru a evita buffer overflow, dar trebuie verificat dacă șirul rezultat este terminat corect cu '\\0', deoarece strncpy nu îl adaugă automat dacă sursa are exact n caractere.",
		  "Cum funcționează funcția strlen și de ce este importantă terminarea șirului cu '\\0'?": "strlen calculează lungimea unui șir până la caracterul nul '\\0', fără a include acest caracter. Dacă șirul nu este terminat corect, funcția poate continua să citească memorie aleatorie, ducând la erori grave și potențiale vulnerabilități.",
		  "Cum poți căuta un caracter într-un șir folosind strchr și ce returnează funcția?": "strchr caută prima apariție a unui caracter într-un șir și returnează un pointer la această poziție, sau NULL dacă nu este găsit. Este utilă pentru împărțirea șirurilor sau pentru a verifica dacă un caracter există într-un șir.",
		  "Ce face funcția strstr și cum se poate folosi pentru a găsi un substring?": "strstr caută prima apariție a unui șir (substring) într-un alt șir. Returnează un pointer la începutul substringului găsit sau NULL dacă nu există. Poate fi folosită pentru verificarea prezenței unui cuvânt într-un text sau pentru parsare.",
		  "Cum se pot elimina spațiile de la începutul și sfârșitul unui șir în C folosind funcțiile standard?": "Nu există o funcție standard directă, dar se poate folosi combination strchr, strlen și manipulare manuală a pointerilor. Se identifică primul caracter diferit de spațiu și ultimul caracter diferit de spațiu, apoi se ajustează șirul prin mutare și adăugarea de '\\0'.",
		  "Cum poți separa un șir în token-uri folosind strtok și care sunt limitele acestei funcții?": "strtok împarte un șir în token-uri delimitate de un set de caractere. Prima apelare primește șirul original, iar apelările ulterioare primesc NULL. Este distructivă (modifică șirul original) și nu este thread-safe, deoarece folosește o variabilă statică internă.",
		  "Ce alternative mai sigure există pentru manipularea șirurilor în C și când ar trebui folosite?": "Alternativa modernă este folosirea funcțiilor sigure definite în C11, cum ar fi strncpy_s, strcat_s. De asemenea, se poate opta pentru librării externe care gestionează automat dimensiunile și memoria (ex: glib). Aceste soluții reduc riscurile de buffer overflow și accidentele de memorie."
		},
		"Conceptul de funcție și transferul parametrilor":
		{
		  "Care este rolul unei funcții în C și cum ajută la structurarea codului?": "O funcție în C reprezintă un bloc de cod reutilizabil care îndeplinește o anumită sarcină. Funcțiile ajută la împărțirea programului în părți mai mici, mai ușor de înțeles, testat și întreținut. Ele contribuie la modularitate și reduc redundanța codului.",
		  "Cum se declară și cum se definește o funcție în C?": "O funcție se declară prin prototip (ex: int suma(int a, int b);) și se definește ulterior, specificând blocul de instrucțiuni. Declarația informează compilatorul despre tipul de return și parametri, iar definirea oferă implementarea efectivă.",
		  "Care este diferența dintre parametrii formali și argumentele efective într-o funcție?": "Parametrii formali sunt variabilele definite în antetul funcției și acționează ca locuri rezervate. Argumentele efective sunt valorile concrete transmise în momentul apelului funcției. La apel, argumentele sunt copiate în parametrii formali.",
		  "Cum funcționează transferul parametrilor prin valoare în C și care sunt implicațiile?": "În C, transferul parametrilor se face implicit prin valoare, ceea ce înseamnă că funcția primește o copie a valorilor argumentelor. Modificările asupra parametrilor în funcție nu afectează variabilele originale din afara funcției.",
		  "Cum se pot modifica variabilele originale dintr-o funcție folosind pointeri?": "Pentru a modifica variabilele originale, se transmit adresele lor (pointeri) ca argumente. Funcția va opera direct asupra zonelor de memorie indicate de pointeri, permițând astfel schimbarea valorilor originale.",
		  "Care sunt avantajele și dezavantajele folosirii pointerilor pentru transferul parametrilor?": "Avantajele includ posibilitatea de a modifica datele originale și eficiența (se transmite doar adresa, nu se copiază valorile mari). Dezavantajele sunt riscul de dereferențiere incorectă, acces la memorie nevalidă și complexitate crescută în gestionarea codului.",
		  "Ce se întâmplă dacă returnezi adresa unei variabile locale dintr-o funcție?": "Este o eroare gravă deoarece variabilele locale sunt distruse la finalul funcției, iar adresa devine invalidă (dangling pointer). Orice acces ulterior la această adresă duce la comportament nedefinit.",
		  "Cum poți simula transferul prin referință în C, care nu există nativ?": "Transferul prin referință se poate simula prin transmiterea adreselor variabilelor (pointeri) ca argumente. Astfel, funcția poate modifica direct valorile originale, similar cu referința din alte limbaje (ex: C++).",
		  "Cum poate afecta optimizarea compilatorului comportamentul funcțiilor care folosesc pointeri?": "Optimizările pot presupune că pointerii nu se suprapun (no aliasing) și pot reorganiza accesările memoriei. Dacă nu se respectă aceste presupuneri, pot apărea rezultate incorecte. Se pot folosi calificatori precum restrict (în C99) pentru a clarifica intențiile.",
		  "Ce avantaje oferă modularizarea programului prin funcții în ceea ce privește testarea și întreținerea?": "Folosirea funcțiilor permite testarea independentă a fiecărui modul, depistarea rapidă a erorilor și reutilizarea codului. Întreținerea devine mai simplă deoarece modificările locale nu afectează întregul program, iar codul este mai ușor de citit și documentat."
		},
		"Clase de funcții în limbajul C":
		{
		  "Ce reprezintă o funcție recursivă în C și cum se gestionează apelurile sale?": "O funcție recursivă este una care se apelează pe sine însăși, direct sau indirect. Gestionarea apelurilor implică stiva de apeluri, unde fiecare apel păstrează contextul local. Este important să existe o condiție de oprire pentru a preveni recursivitatea infinită și depășirea stivei.",
		  "Cum se definește și ce avantaje oferă o funcție inline în C?": "Funcțiile inline sunt sugerate compilatorului să fie extinse în locul apelului, evitând costul apelului de funcție. Acest lucru poate îmbunătăți performanța la funcții scurte, dar excesul de inline poate crește dimensiunea codului binar.",
		  "Ce este o funcție variadică și cum se utilizează în C?": "Funcțiile variadice pot primi un număr variabil de argumente (ex: printf). Se folosesc macro-uri și tipuri speciale din <stdarg.h> (va_list, va_start, va_arg, va_end) pentru a itera prin argumente variabile în timpul execuției.",
		  "Cum se pot implementa funcții care întorc pointeri și care sunt riscurile asociate?": "Funcțiile pot returna pointeri către zone de memorie alocate dinamic sau către variabile statice globale. Riscurile includ returnarea adreselor variabilelor locale (invalid după ieșire) sau scurgeri de memorie dacă nu se eliberează spațiul alocat dinamic.",
		  "Ce sunt funcțiile statice în C și cum influențează vizibilitatea lor?": "Funcțiile statice au vizibilitate limitată la fișierul sursă în care sunt definite. Nu pot fi apelate din alte fișiere. Acest lucru ajută la încapsulare și evită conflictele de nume la nivelul proiectului.",
		  "Cum funcționează funcțiile cu prototip și fără prototip în C și care este recomandarea actuală?": "Funcțiile cu prototip specifică tipurile parametrilor, iar compilatorul poate verifica corectitudinea apelurilor. Funcțiile fără prototip permit orice parametri, ceea ce poate duce la erori. Se recomandă folosirea prototipurilor pentru siguranță și claritate.",
		  "Ce rol au funcțiile recursiv tail-call (tail recursion) și cum sunt optimizate de compilator?": "Tail recursion este o recursie unde apelul recursiv este ultima operație din funcție. Compilatoarele moderne pot optimiza astfel încât să nu crească stiva apelurilor (optimizare tail call), transformând recursivitatea în iterare internă.",
		  "Ce sunt funcțiile lambda în C și există suport nativ pentru ele?": "Limbajul C nu suportă funcții lambda nativ (funcții anonime inline), spre deosebire de C++11+. Pentru comportamente similare, se pot folosi pointeri la funcții și structuri care conțin contextul, dar nu există o sintaxă dedicată.",
		  "Cum pot fi folosite pointerii la funcții pentru implementarea de callback-uri în C?": "Pointerii la funcții permit transmiterea adresei unei funcții ca argument, pentru a fi apelată ulterior (ex: la evenimente sau sortări personalizate). Aceasta crește flexibilitatea și permite decuplarea codului.",
		  "Ce sunt funcțiile inline static și când este util să fie folosite împreună?": "Funcțiile inline static combină limitarea vizibilității la fișier și sugestia de a înlocui apelul cu codul funcției pentru optimizare. Sunt utile pentru funcții mici, folosite doar local, pentru a evita overhead-ul apelului și conflictele de simboluri."
		},
		"Funcții recursive":
		{
		  "Ce este o funcție recursivă și cum funcționează apelurile sale în C?": "O funcție recursivă este o funcție care se apelează pe sine însăși direct sau indirect. La fiecare apel recursiv, se creează un nou context de execuție pe stiva apelurilor, iar funcția continuă să se apeleze până când se îndeplinește o condiție de oprire, evitând recursivitatea infinită.",
		  "Care sunt elementele esențiale pentru a implementa o funcție recursivă corectă?": "Elementele esențiale includ o condiție de bază care oprește recursivitatea și o reducere a problemei la fiecare apel recursiv. Fără o condiție de oprire clară, funcția va intra într-o recursie infinită și va cauza depășirea stivei (stack overflow).",
		  "Cum poate fi comparată recursivitatea cu iterația și când este recomandată fiecare?": "recursivitatea oferă o soluție elegantă pentru probleme care au o structură recursivă naturală (ex. arbori, factorizări). Itierația este mai eficientă în termeni de consum de memorie și performanță. Recomandarea depinde de claritatea codului și constrângerile de resurse.",
		  "Cum influențează adâncimea recursiei performanța și stabilitatea unui program în C?": "O adâncime prea mare a recursiei poate duce la depășirea stivei și crash al programului. Performanța scade datorită costului apelurilor repetate și gestiunii stivei. În situații cu recursii adânci, se recomandă transformarea în iterație sau optimizarea tail call.",
		  "Ce este optimizarea tail call și cum poate fi aplicată în C?": "Optimarea tail call este o transformare compilator care înlocuiește apelurile recursive finale cu salturi simple, reducând consumul de stivă. C standard nu garantează optimizarea, dar unele compilatoare o aplică pentru funcții cu apel recursiv la final.",
		  "Cum pot fi folosite funcțiile recursive pentru a traversa structuri de date precum arbori sau liste în C?": "Funcțiile recursive sunt ideale pentru traversarea arborilor și listelor deoarece pot procesa nodul curent și apoi apela recursiv pentru subnoduri sau următorul element. Astfel, codul rămâne clar și concis, evitând complexitatea iterativă.",
		  "Care sunt riscurile și posibilele erori comune în utilizarea funcțiilor recursive în C?": "Riscurile includ recursivitatea infinită, depășirea stivei, consum excesiv de memorie și erori de calcul cauzate de lipsa condiției de oprire. De asemenea, uneori este dificil de urmărit execuția și depistarea erorilor în recursie profundă.",
		  "Cum se poate calcula factorialul unui număr folosind recursivitatea în C și ce limitări există?": "Factorialul poate fi calculat recursiv: factorial(n) = n * factorial(n-1), cu factorial(0) = 1. Limitările includ faptul că pentru valori mari de n, stiva se poate umple și se pot obține rezultate incorecte din cauza overflow-ului numeric.",
		  "Cum poate fi implementată o funcție recursivă pentru calcularea elementelor din șirul Fibonacci în C și ce probleme de performanță pot apărea?": "Funcția Fibonacci recursivă definește fib(n) = fib(n-1) + fib(n-2) cu condiții de bază fib(0)=0 și fib(1)=1. Problema este că are complexitate exponențială din cauza multiplelor apeluri redundante, necesitând optimizări ca memoizarea.",
		  "Cum poate fi utilizată recursivitatea pentru rezolvarea problemelor de backtracking, precum generarea permutărilor în C?": "Recursivitatea permite explorarea tuturor combinațiilor posibile prin apeluri succesive care construiesc soluții parțiale, revenind (backtracking) când o cale nu mai este validă. Aceasta este o metodă naturală și eficientă pentru probleme combinatorii."
		},
		"Argumentele funcției main()":
		{
		  "Care este semnificația argumentelor argc și argv în funcția main() din C?": "Argumentul argc reprezintă numărul de argumente din linia de comandă, inclusiv numele programului, iar argv este un vector de șiruri de caractere (array de pointeri la char) care conține efectiv argumentele primite. argv[0] este de obicei numele programului.",
		  "Cum este utilizat vectorul argv pentru a accesa argumentele din linia de comandă?": "Fiecare element argv[i] este un pointer la un șir de caractere care reprezintă un argument introdus de utilizator. Programul poate itera de la i=1 până la i=argc-1 pentru a accesa fiecare argument în parte, ignorând de obicei argv[0] (numele programului).",
		  "Cum se poate transforma un argument primit în main() într-o valoare numerică?": "Argumentele sunt șiruri de caractere, deci trebuie convertite folosind funcții precum atoi(), atof() sau strtol(). Este importantă validarea pentru a evita erorile generate de conversii invalide.",
		  "Care sunt avantajele folosirii argumentelor din linia de comandă pentru configurarea programului?": "Argumentele din linia de comandă permit configurarea comportamentului programului fără recompilare. Ele oferă flexibilitate, permițând utilizatorului să specifice fișiere de intrare, moduri de execuție, opțiuni și alți parametri dinamici.",
		  "Ce se întâmplă dacă funcția main() este definită fără argumente?": "Se poate defini main() fără argumente, dar în acest caz programul nu va putea accesa direct argumentele din linia de comandă. Totuși, comportamentul este perfect valid și standardul C permite main() să fie definit ca int main(void).",
		  "Cum pot fi tratate spațiile și ghilimelele în argumentele transmise către main()?": "Argumentele cu spații trebuie incluse între ghilimele în linia de comandă, iar shell-ul sau sistemul de operare va gestiona separarea corectă în vectorul argv. Ghilimelele sunt eliminate înainte ca argumentele să fie stocate efectiv în argv.",
		  "Care sunt riscurile posibile la manipularea argumentelor argv în mod direct?": "Manipularea directă a argumentelor poate duce la modificări nedorite asupra datelor originale, acces la indecși în afara limitelor argv sau confuzii între pointeri și șiruri. Este important să se respecte limitele impuse de argc și să se verifice validitatea fiecărui argument.",
		  "Cum poate fi folosit argumentul argv[0] și în ce situații poate diferi conținutul său?": "argv[0] conține, în mod normal, numele programului (calea completă sau relativă). Totuși, în unele sisteme, argv[0] poate fi setat explicit de utilizatorul care lansează procesul (ex: prin exec), deci nu trebuie întotdeauna considerat de încredere pentru identificarea programului.",
		  "Cum pot fi gestionate argumentele opționale și cele obligatorii în main()?": "Se pot parcurge argumentele și valida manual dacă numărul lor (argc) este suficient pentru argumentele obligatorii. Pentru argumentele opționale, se pot defini valori implicite. În programe complexe, se folosesc librării precum getopt() pentru parsare avansată.",
		  "Cum pot fi folosite argumentele din main() pentru a implementa programe portabile și configurabile?": "Folosirea argumentelor permite configurarea externă a programului, evitând hardcodarea valorilor. Aceasta crește portabilitatea, deoarece utilizatorul poate adapta comportamentul fără a modifica sursa, și permite integrarea mai ușoară în scripturi sau sisteme automate."
		},
		"Funcții cu număr variabil de parametrii":
		{
		  "Ce sunt funcțiile cu număr variabil de parametri în C și când sunt utile?": "Funcțiile cu număr variabil de parametri pot accepta un număr diferit de argumente la fiecare apel. Ele sunt utile când nu se știe dinainte câți parametri vor fi necesari, cum ar fi la funcții de tip printf sau funcții care agregă date variabile.",
		  "Cum este definită o funcție cu număr variabil de argumente în C?": "O astfel de funcție este definită cu cel puțin un argument fix, urmat de '...', care indică faptul că pot urma argumente suplimentare. Exemplu: int func(int n, ...) indică că primul argument este obligatoriu, iar restul sunt variabile.",
		  "Ce librărie standard oferă suport pentru manipularea argumentelor variabile și ce macros-uri sunt utilizate?": "Librăria <stdarg.h> oferă suport pentru astfel de funcții. Macros-urile principale sunt va_list, va_start, va_arg și va_end. Acestea permit inițializarea listei, extragerea argumentelor și eliberarea resurselor.",
		  "Cum se folosește macro-ul va_start și ce rol are primul argument fix?": "va_start initializează lista de argumente variabile și are nevoie de ultimul argument fix ca referință pentru a ști de unde să înceapă citirea argumentelor suplimentare. Fără un argument fix, lista nu poate fi determinată corect.",
		  "Cum pot fi citite în siguranță argumentele dintr-o funcție variadică?": "Argumentele trebuie extrase în ordinea în care au fost transmise folosind va_arg, specificând tipul așteptat. Este responsabilitatea programatorului să știe câte și ce tipuri de argumente urmează, altfel pot apărea erori de memorie sau comportament nedefinit.",
		  "Care sunt principalele riscuri și dezavantaje ale funcțiilor variadice în C?": "Riscurile includ lipsa verificării de tip la compilare, dificultatea în a verifica numărul de argumente și posibilitatea de corupere a memoriei dacă argumentele sunt citite incorect. De asemenea, menținerea și depanarea unor astfel de funcții este mai dificilă.",
		  "Cum poate fi implementată o funcție care calculează suma unui număr variabil de întregi în C?": "Se definește funcția cu un argument fix ce indică numărul de valori (ex: int sum(int count, ...)). Apoi, se folosește va_list și va_arg pentru a itera prin argumente și a acumula suma. Este important să se încheie cu va_end pentru a elibera lista.",
		  "Cum sunt tratate tipurile de date diferite în funcțiile variadice și care sunt limitările?": "Argumentele variadice nu păstrează informații despre tipul lor, deci programatorul trebuie să știe în ce ordine și ce tipuri se așteaptă. Nu există siguranță la tip (type safety), ceea ce poate duce la erori grave dacă argumentele sunt interpretate greșit.",
		  "De ce se folosesc adesea argumentele variadice împreună cu argumente format, cum este cazul printf?": "Argumentele format (stringul de format) servesc drept descriere pentru tipurile și ordinea argumentelor suplimentare. Astfel, funcția poate determina corect ce tipuri trebuie citite și cum să fie procesate, reducând riscul de interpretare greșită.",
		  "Cum pot fi evitate erorile comune atunci când se lucrează cu funcții variadice?": "Se recomandă să se folosească un argument fix clar care să indice numărul de argumente suplimentare, să se documenteze exact ordinea și tipurile așteptate, să se utilizeze eventual macro-uri de verificare și să se limiteze pe cât posibil utilizarea funcțiilor variadice doar unde este strict necesar."
		},
		"Structuri autoreferite":
		{
		  "Ce este o structură autoreferită în C și cum se declară?": "O structură autoreferită este o structură care include un pointer la o structură de același tip, permițând crearea de structuri dinamice și recursive, cum ar fi liste, arbori sau grafuri. Declararea se face astfel: struct Nod { int data; struct Nod *next; };",
		  "De ce nu se poate include direct o instanță a aceleași structuri în interiorul unei structuri autoreferite?": "Dacă s-ar include direct o instanță (adică un obiect de tip structură) în interiorul aceleași structuri, s-ar genera o definiție recursivă infinită și compilatorul nu ar putea aloca o dimensiune fixă. De aceea, se folosește un pointer, care are o dimensiune fixă.",
		  "Ce tipuri de structuri de date se pot implementa folosind structuri autoreferite?": "Cu ajutorul structurilor autoreferite se pot implementa liste simple și duble înlănțuite, stive, cozi, arbori binari sau generali, grafuri și alte structuri dinamice care necesită referințe între noduri.",
		  "Cum gestionează memoria o structură autoreferită în comparație cu o structură simplă?": "Structurile autoreferite necesită alocare dinamică (malloc/free) pentru fiecare nod, deoarece legăturile dintre noduri sunt create la execuție. În structurile simple, toată memoria este alocată static sau automat (pe stivă), fără alocări dinamice intermediare.",
		  "Cum poate fi definit un nod al unei liste simplu înlănțuite folosind o structură autoreferită?": "Se definește astfel: struct Nod { int data; struct Nod *next; };. Fiecare nod conține un câmp data și un pointer next către următorul nod din listă. Ultimul nod va avea next egal cu NULL.",
		  "Ce avantaje oferă structurile autoreferite în modelarea structurilor dinamice de date?": "Structurile autoreferite permit alocarea și eliberarea flexibilă a memoriei în timpul execuției, oferind o gestionare eficientă a spațiului și posibilitatea de a crea structuri de date extensibile, fără a necesita dimensiuni fixe predefinite.",
		  "Cum poate fi implementată traversarea unei structuri autoreferite, de exemplu, o listă?": "Traversarea se realizează prin iterarea pointerului next până când acesta devine NULL. Exemplu: for (struct Nod *p = cap; p != NULL; p = p->next) { /* procesare */ }.",
		  "Ce probleme pot apărea la eliberarea memoriei ocupate de structuri autoreferite?": "Dacă nu se parcurge și eliberează explicit fiecare nod (folosind free), pot apărea scurgeri de memorie (memory leaks). Este important să se itereze prin întreaga structură și să se elibereze fiecare nod înainte de a pierde referințele.",
		  "Cum pot fi implementate structuri mai complexe, cum ar fi arborii binari, folosind structuri autoreferite?": "Se definește structura astfel: struct Nod { int data; struct Nod *st, *dr; };. Fiecare nod are pointeri către subarborele stâng și drept, permițând astfel construcția recursivă a arborelui.",
		  "Ce rol are recursivitatea în funcțiile care lucrează cu structuri autoreferite?": "Recursivitatea este esențială pentru operații precum traversarea arborilor, inserare, ștergere sau căutare. Prin apeluri recursive, funcțiile pot explora în mod natural structurile autoreferite, reflectând structura lor ierarhică."
		},
		"Substituirea simbolică – tipul enum":
		{
		  "Ce este tipul enum în C și care este scopul său principal?": "Tipul enum (enumerare) în C este un tip de date definit de utilizator care permite asocierea unor identificatori simbolici cu valori întregi. Scopul principal este creșterea clarității codului și înlocuirea valorilor magice (constante numerice) cu nume sugestive.",
		  "Cum se declară o enumerare și ce valori implicite primesc elementele?": "O enumerare se declară astfel: enum Zi { Luni, Marti, Miercuri, Joi, Vineri };. Implicit, primul element primește valoarea 0, iar fiecare element următor primește valoarea anterioară plus 1.",
		  "Cum se pot atribui valori explicite elementelor unei enumerări?": "Valorile explicite se pot atribui astfel: enum Zi { Luni = 1, Marti = 3, Miercuri, Joi = 7 };. Dacă nu se specifică o valoare, elementul preia valoarea precedentă +1 (ex. Miercuri va primi 4 în acest caz).",
		  "Ce avantaje oferă enum față de #define pentru definirea constantelor?": "Enum oferă un tip de date clar definit, permite controlul valorilor și îmbunătățește depanarea (debugging), deoarece valorile pot fi vizualizate ca nume simbolice. #define este doar o substituție textuală și nu are tip, ceea ce poate duce la erori de tipare.",
		  "Cum se poate utiliza o enumerare într-o instrucțiune switch?": "Enumerările sunt adesea folosite în switch pentru claritate: switch (zi) { case Luni: /* actiune */ break; case Marti: /* actiune */ break; ... }. Astfel, codul devine mai ușor de întreținut și de înțeles.",
		  "Ce tip intern au valorile enum și ce consecințe poate avea acest lucru?": "Valorile enum sunt, în general, reprezentate intern ca întregi (int). Acest lucru înseamnă că pot fi comparate, stocate și transmise ca întregi, dar și că pot exista conversii implicite care pot genera erori dacă nu sunt gestionate corect.",
		  "Cum poate fi folosit enum pentru a reprezenta stările unui obiect sau proces?": "Se poate defini, de exemplu: enum Stare { Initializare, InExecutie, Eroare, Finalizat };. Astfel, variabilele pot lua doar valorile definite, facilitând controlul și prevenirea erorilor logice cauzate de valori invalide.",
		  "Este posibil să se definească două enumerări diferite cu aceleași nume de elemente?": "Nu, în același spațiu de nume global, numele elementelor din enum trebuie să fie unice. Dacă două enumerări diferite au elemente cu același nume, se va genera eroare de compilare.",
		  "Cum se poate controla dimensiunea ocupată de enum în memorie?": "Standardul C nu permite controlul direct al dimensiunii enum; valorile sunt reprezentate ca int. În C99 și în unele compilatoare moderne, există extensii pentru a specifica tipuri întregi mai mici, dar acestea nu sunt portabile și depind de implementare.",
		  "Ce riscuri există atunci când se folosesc valori în afara intervalului definit de enum?": "În C, un enum este tratat ca int, deci tehnic poate lua orice valoare întreagă. Dacă o variabilă enum primește o valoare nevalidă (care nu corespunde niciunui element), logica programului poate deveni imprevizibilă. De aceea, se recomandă verificarea explicită a valorilor înainte de utilizare."
		},
		"Macrodefiniții":
		{
		  "Ce este o macrodefiniție în C și cum diferă de o funcție obișnuită?": "O macrodefiniție este o instrucțiune preprocesor (define) care înlocuiește textual un identificator cu o expresie specificată înainte de compilare. Spre deosebire de funcții, macrodefinițiile nu au tip și nu verifică tipurile parametrilor, iar substituirea are loc pur textual.",
		  "Cum se definește o macrodefiniție cu parametri și care sunt avantajele ei?": "Se definește astfel: #define MAX(a,b) ((a) > (b) ? (a) : (b)). Avantajele includ evitarea apelurilor de funcții și eliminarea suprasarcinii (overhead-ului) de la runtime, deoarece totul se rezolvă la preprocesare.",
		  "Ce probleme pot apărea din cauza substituției textuale în macrodefiniții?": "Pot apărea efecte laterale neașteptate, mai ales dacă parametrii nu sunt între paranteze. De exemplu: #define SQR(x) x*x, apelat ca SQR(a+1) devine a+1*a+1, rezultând erori de evaluare.",
		  "Cum pot fi evitate erorile de evaluare în macrodefiniții cu parametri?": "Se recomandă folosirea parantezelor în jurul fiecărui parametru și în jurul expresiei finale: #define SQR(x) ((x)*(x)). Astfel, se păstrează ordinea corectă a operațiilor.",
		  "Ce diferență există între o constantă definită cu #define și una definită cu const?": "#define efectuează substituție textuală și nu ocupă memorie, fiind prelucrată de preprocesor. const definește o variabilă constantă cu un tip clar, ceea ce permite verificarea de tip și depistarea erorilor la compilare.",
		  "Cum pot fi folosite macrodefinițiile pentru generarea de cod portabil?": "Se pot defini macro-uri condiționale în funcție de platformă sau compilator: #ifdef WINDOWS #define PATH_SEPARATOR '\\\\' #else #define PATH_SEPARATOR '/' #endif. Astfel, codul se adaptează automat mediului de compilare.",
		  "Ce sunt macro-urile variadice și cum se pot defini în C?": "Macro-urile variadice acceptă un număr variabil de argumente și se definesc astfel: #define PRINT(fmt, ...) printf(fmt, __VA_ARGS__). Ele sunt utile pentru a crea funcții-macro care acceptă formate flexibile (similar printf).",
		  "Ce riscuri de securitate pot apărea atunci când se abuzează de macrodefiniții?": "Macrodefinițiile pot ascunde logica reală și pot introduce efecte laterale neașteptate, ceea ce îngreunează depanarea și verificarea codului. De asemenea, pot duce la comportamente neprevăzute dacă parametrii includ expresii complexe sau apeluri de funcții.",
		  "Cum poate fi verificată valoarea unei macrodefiniții în timpul compilării?": "Prin directiva #ifdef sau #if definit: #ifdef DEBUG // cod de debug #endif. Astfel, putem include sau exclude porțiuni de cod în funcție de definiția macro-urilor, controlând configurarea aplicației la compilare.",
		  "Ce bune practici se recomandă atunci când se folosesc macrodefiniții?": "Se recomandă folosirea parantezelor peste tot, limitarea utilizării lor pentru constante sau cod foarte scurt, folosirea const sau inline pentru funcții scurte în loc de macro, și documentarea clară pentru a evita efectele ascunse."
		},
		"Abstractizarea datelor, conceptul de clasă, supraîncărcarea operatorilor și funcțiilor":
		{
		  "Ce înseamnă abstractizarea datelor și cum este realizată în C++?": "Abstractizarea datelor în C++ presupune ascunderea detaliilor de implementare și expunerea doar a unei interfețe publice. Este realizată prin clase, unde membrii pot fi declarați private sau protected, iar interfața publică permite manipularea obiectelor fără a expune structura internă.",
		  "Ce este o clasă în C++ și cum diferă de structura din C?": "O clasă în C++ este o extensie a structurilor din C, permițând controlul accesului (public, private, protected), suport pentru funcții-membru și mecanisme OOP ca moștenirea și polimorfismul. În structura din C, toți membrii sunt publici și nu există funcții asociate.",
		  "Cum se realizează ascunderea datelor într-o clasă în C++ și care este rolul modificatorilor de acces?": "Ascunderea datelor se realizează declarând membrii de date ca private sau protected. Modificatorii de acces controlează cine poate accesa sau modifica acești membri: private permite acces doar din interiorul clasei, protected permite acces în clasele derivate, iar public permite acces global.",
		  "Ce este supraîncărcarea funcțiilor în C++ și cum se utilizează?": "Supraîncărcarea funcțiilor permite definirea mai multor funcții cu același nume, dar cu semnături diferite (tipuri sau număr de parametri). Compilatorul alege automat funcția corectă pe baza tipurilor argumentelor la apel.",
		  "Ce avantaje aduce supraîncărcarea operatorilor în C++ și cum se declară?": "Supraîncărcarea operatorilor permite definirea unui comportament personalizat pentru operatori (ex. +, -, ==) pentru tipuri definite de utilizator. Se declară ca funcții-membru sau funcții prietene, de exemplu: MyClass operator+(const MyClass& other).",
		  "Cum pot fi ascunși membrii moșteniți de o clasă din clasa de bază?": "Prin folosirea cuvântului cheie private înaintea numelui clasei de bază la declararea relației de moștenire.",
		  "Care este diferența între o funcție-membru normală și una statică într-o clasă C++?": "O funcție-membru normală operează asupra unei instanțe concrete (are acces la this), în timp ce o funcție statică aparține clasei în sine, nu are acces la membrii instanței și poate fi apelată fără a crea un obiect.",
		  "Cum se poate folosi supraîncărcarea operatorului de indexare [] într-o clasă și când este utilă?": "Operatorul [] poate fi supraîncărcat pentru a permite accesul la elemente interne ca într-un array: T& operator[](int index). Este util, de exemplu, pentru clase care implementează liste, vectori dinamici sau containere personalizate.",
		  "Ce înseamnă polimorfismul în C++ și ce legătură are cu abstractizarea?": "Polimorfismul permite utilizarea unui pointer sau referință la clasa de bază pentru a apela metode suprascrise în clasele derivate. Abstractizarea ascunde implementarea specifică, iar polimorfismul permite folosirea unui cod comun pentru obiecte de tipuri diferite.",
		  "Ce riscuri sau probleme pot apărea atunci când se abuzează de supraîncărcarea operatorilor?": "Abuzul de supraîncărcare poate duce la un cod confuz și greu de întreținut, mai ales dacă operatorii au semnificații neașteptate. De exemplu, supraîncărcarea operatorului '+' pentru a face concatenări între obiecte care nu au legătură logică poate produce confuzie în utilizarea codului."
		},
		"Polimorfism":
		{
		  "Ce este polimorfismul în C++ și cum se diferențiază de alte forme de reutilizare a codului?": "Polimorfismul este capacitatea unui obiect de a se comporta diferit în funcție de contextul în care este folosit, permițând apelarea aceleași metode pe obiecte diferite care implementează comportamente proprii. Spre deosebire de moștenire, care implică preluarea directă a codului, polimorfismul permite tratarea uniformă a obiectelor derivate prin intermediul pointerilor sau referințelor la clasa de bază.",
		  "Care sunt tipurile principale de polimorfism în C++?": "Există două tipuri principale: polimorfism static (la compilare), realizat prin supraîncărcarea funcțiilor și a operatorilor, și polimorfism dinamic (la execuție), obținut prin folosirea funcțiilor virtuale și a moștenirii. Polimorfismul dinamic permite comportamente diferite la runtime.",
		  "Cum funcționează mecanismul funcțiilor virtuale în polimorfismul dinamic?": "Funcțiile virtuale sunt declarate în clasa de bază și pot fi redefinite (override) în clasele derivate. La execuție, apelurile la aceste funcții se rezolvă folosind tabela virtuală (vtable), ceea ce permite chemarea metodei corespunzătoare obiectului real, chiar dacă este referit printr-un pointer la clasa de bază.",
		  "Ce este o clasă abstractă și cum contribuie aceasta la implementarea polimorfismului?": "O clasă abstractă este o clasă care conține cel puțin o funcție virtuală pură (de forma virtual void f() = 0;). Ea nu poate fi instanțiată direct și servește drept interfață comună pentru clasele derivate, forțându-le să implementeze metodele virtuale pure.",
		  "Ce avantaje aduce polimorfismul în proiectele mari și modulare?": "Polimorfismul permite extinderea ușoară a codului fără a modifica codul existent, promovează separarea interfeței de implementare și facilitează scrierea de funcții generice care pot lucra cu obiecte diferite prin pointeri sau referințe la clasa de bază.",
		  "Cum poate polimorfismul să ducă la probleme de performanță și cum pot fi evitate?": "Polimorfismul dinamic introduce un overhead de timp datorită lookup-ului în tabela virtuală. În aplicații critice, trebuie analizat dacă această flexibilitate este necesară sau dacă se pot folosi alternative precum polimorfismul static (template-uri) pentru a reduce costurile la runtime.",
		  "Ce se întâmplă dacă destructorul clasei de bază nu este declarat virtual?": "Dacă destructorul nu este virtual, atunci când un obiect derivat este șters printr-un pointer la clasa de bază, se va apela doar destructorul clasei de bază, ceea ce poate duce la scurgeri de memorie sau resurse neeliberate, deoarece distrugătorii derivatelor nu sunt apelați.",
		  "Cum se poate combina polimorfismul cu template-urile în C++?": "Template-urile oferă polimorfism static (la compilare), permițând definirea de clase și funcții generice. Polimorfismul dinamic și template-urile pot fi combinate, de exemplu, când o clasă generică folosește pointeri la clase de bază cu metode virtuale pentru a manipula obiecte concrete.",
		  "Ce este downcasting-ul și care sunt riscurile sale în contextul polimorfismului?": "Downcasting-ul presupune convertirea unui pointer sau referință la clasa de bază într-un pointer sau referință la o clasă derivată. Este riscant deoarece poate produce comportamente nedefinite dacă obiectul real nu este de tipul derivat. dynamic_cast poate fi folosit pentru verificarea în siguranță a tipului la runtime.",
		  "Cum ajută polimorfismul la implementarea plugin-urilor sau a arhitecturilor extensibile?": "Polimorfismul permite definirea unei interfețe comune pentru module (plugin-uri), iar aplicația principală poate apela metodele definite în interfață fără a cunoaște detaliile implementării. Astfel, noi funcționalități pot fi adăugate fără a modifica codul existent, doar prin adăugarea de clase derivate care respectă interfața."
		},
		"Clase derivate":
		{
		  "Care este diferența dintre moștenirea publică, protected și private în C++?": "În moștenirea publică, membrii publici și protected ai clasei de bază rămân respectiv publici și protected în clasa derivată. În moștenirea protected, aceștia devin protected, iar în moștenirea private, devin private. Moștenirea publică este folosită pentru relații de tipul 'este un', iar celelalte pentru restrângerea accesului.",
		  "Ce este o clasă derivată în C++ și care este scopul ei principal?": "O clasă derivată este o clasă care extinde o altă clasă (clasa de bază), moștenind membrii și comportamentele acesteia. Scopul principal este reutilizarea codului și extinderea funcționalității clasei de bază, permițând adăugarea sau redefinirea comportamentelor.",
		  "Cum se definește o clasă derivată și ce semnificație au specificatorii public, protected și private?": "O clasă derivată se definește folosind sintaxa: class Derived : public Base. Specificatorul public face ca membrii publici și protected ai clasei de bază să rămână publici și protected în derivată. Protected îi transformă în protected, iar private îi transformă în private, limitând accesul în afara clasei derivate.",
		  "Ce este supraîncărcarea (overriding) funcțiilor într-o clasă derivată?": "Supraîncărcarea funcțiilor într-o clasă derivată înseamnă redefinirea unei funcții virtuale declarate în clasa de bază pentru a oferi un comportament specific clasei derivate. Aceasta permite polimorfismul dinamic, asigurând că funcția clasei potrivite este apelată la runtime.",
		  "Ce este constructorul clasei derivate și cum interacționează cu constructorul clasei de bază?": "Constructorul clasei derivate poate inițializa membrii proprii și trebuie să invoce constructorul clasei de bază pentru a inițializa partea moștenită. Acest lucru se face explicit în lista de inițializare: Derived(...) : Base(...) {}.",
		  "Care este rolul funcției virtuale pure în contextul claselor derivate?": "Funcțiile virtuale pure (virtual void f() = 0;) obligă clasele derivate să le implementeze, făcând astfel clasa de bază abstractă. Clasele derivate devin concrete doar după ce definesc aceste funcții, ceea ce forțează respectarea unei interfețe comune.",
		  "Cum se gestionează distrugerea obiectelor atunci când se utilizează clase derivate?": "Este important ca destructorul clasei de bază să fie declarat virtual. Astfel, la distrugerea unui obiect derivat printr-un pointer la clasa de bază, se vor apela corect distrugătorii în lanț (de la derivată la bază), evitând scurgerile de resurse.",
		  "Ce este moștenirea multiplă și care sunt potențialele probleme în clasele derivate?": "Moștenirea multiplă permite unei clase derivate să moștenească de la mai multe clase de bază. Problemele potențiale includ ambiguitatea (dacă clasele de bază au membri cu același nume) și diamantul moștenirii, care se rezolvă folosind moștenirea virtuală.",
		  "Cum poate fi restricționată suprascrierea funcțiilor în clasele derivate?": "În C++11 și ulterior, cuvântul cheie final poate fi folosit pentru a împiedica suprascrierea unei funcții într-o clasă derivată: virtual void func() final;. Astfel, nicio altă clasă derivată nu mai poate redefini acea funcție.",
		  "Care este diferența între moștenirea publică și moștenirea protected într-o clasă derivată?": "În moștenirea publică, membrii publici și protected ai clasei de bază își păstrează vizibilitatea originală în clasa derivată. În moștenirea protected, atât public cât și protected devin protected în clasa derivată, restricționând astfel accesul din exterior."
		},
		"Moștenire, funcții virtuale":
		{
		  "Cum pot clasele derivate să acceseze membrii protected ai clasei de bază?": "Clasele derivate pot accesa direct membrii protected ai clasei de bază ca și cum ar fi proprii. Aceasta le permite să extindă și să modifice comportamentul moștenit, păstrând totuși encapsularea față de exterior, deoarece acei membri nu sunt publici.",
		  "Cum se definește moștenirea publică și ce efect are asupra accesului membrilor clasei de bază?": "Moștenirea publică se definește folosind sintaxa class Derived : public Base. Ea face ca membrii publici ai clasei de bază să rămână publici în derivată și membrii protected să rămână protected, în timp ce membrii private rămân inaccesibili direct în derivată.",
		  "Ce este o funcție virtuală și cum permite implementarea polimorfismului dinamic?": "O funcție virtuală este o funcție membră declarată cu keyword-ul virtual în clasa de bază. Ea permite claselor derivate să redefinească comportamentul funcției, iar la runtime, apelul se rezolvă în funcție de tipul obiectului real, nu de tipul pointerului sau referinței.",
		  "Ce este tabela virtuală (vtable) și care este rolul ei în funcțiile virtuale?": "Tabela virtuală este o structură generată automat de compilator, care conține adresele funcțiilor virtuale pentru fiecare clasă. Ea permite mecanismului de runtime să apeleze funcția corectă a obiectului real atunci când se utilizează pointeri sau referințe la clasa de bază.",
		  "Cum se definesc funcțiile virtuale pure și ce înseamnă pentru clasa de bază?": "Funcțiile virtuale pure se definesc folosind sintaxa virtual void f() = 0;. O clasă care conține cel puțin o funcție virtuală pură devine clasă abstractă și nu poate fi instanțiată direct, ci doar prin clasele derivate care implementează funcția pură.",
		  "Ce probleme pot apărea dacă destructorul clasei de bază nu este declarat virtual?": "Dacă destructorul nu este virtual, distrugerea unui obiect derivat printr-un pointer la clasa de bază va apela doar destructorul clasei de bază, ceea ce poate duce la scurgeri de memorie sau resurse neeliberate, deoarece destructorul clasei derivate nu este apelat.",
		  "Cum se pot redefini funcțiile virtuale în clasele derivate și cum se folosesc cuvântul cheie override?": "Funcțiile virtuale se pot redefini (override) în clasele derivate scriind o implementare nouă cu aceeași semnătură. În C++11 și ulterior, se recomandă adăugarea cuvântului cheie override pentru claritate și pentru ca compilatorul să verifice corectitudinea suprascrierii.",
		  "Care este diferența între funcțiile virtuale și cele non-virtuale în contextul moștenirii?": "Funcțiile non-virtuale sunt legate static (la compilare), deci apelul este rezolvat în funcție de tipul pointerului sau referinței. Funcțiile virtuale sunt legate dinamic (la runtime), permițând apelarea implementării corecte a obiectului derivat, chiar prin pointer la clasa de bază.",
		  "Cum se poate împiedica suprascrierea unei funcții virtuale într-o clasă derivată?": "Pentru a împiedica suprascrierea, se folosește cuvântul cheie final: virtual void f() final;. Astfel, în clasele derivate ulterioare, funcția nu mai poate fi redefinită, ceea ce ajută la menținerea unui comportament stabil și previzibil.",
		  "Cum contribuie moștenirea și funcțiile virtuale la implementarea unui design orientat pe interfețe?": "Moștenirea și funcțiile virtuale permit definirea de clase abstracte (interfețe) care descriu un set de funcționalități comune, fără implementare. Clasele derivate implementează aceste funcționalități, permițând clientului să lucreze cu interfețe comune, decuplate de implementările concrete."
		}
	},
	"Baze de date":
	{
		"Structuri de date, operatori, restricţii de integritate":
		{
		  "Ce sunt principalele structuri de date utilizate în SQL și cum sunt ele reprezentate în tabele?": "În SQL, principalele structuri de date sunt tabelele, care reprezintă colecții de rânduri și coloane. Fiecare coloană are un tip de date bine definit (ex: INTEGER, VARCHAR, DATE), iar rândurile stochează valorile efective. Alte structuri includ vizualizările (views), indecșii și relațiile între tabele (prin chei străine).",
		  "Cum se folosesc operatorii logici și de comparație în SQL pentru filtrarea datelor?": "Operatorii de comparație (>, <, =, >=, <=, <>, BETWEEN, LIKE) și operatorii logici (AND, OR, NOT) sunt utilizați în clauza WHERE pentru a filtra rândurile returnate de o interogare. Ei permit construirea de condiții complexe pentru selectarea precisă a datelor relevante.",
		  "Ce reprezintă restricția PRIMARY KEY și ce rol are într-o structură de date SQL?": "Restricția PRIMARY KEY identifică în mod unic fiecare rând dintr-o tabelă. Aceasta implică faptul că valorile din coloanele definite ca PRIMARY KEY nu pot fi NULL și nu pot exista duplicate. În plus, o tabelă poate avea o singură cheie primară.",
		  "Cum funcționează restricția FOREIGN KEY și cum contribuie la integritatea referențială?": "Restricția FOREIGN KEY definește o relație între două tabele, stabilind că valorile dintr-o coloană (sau combinație de coloane) trebuie să existe deja în coloana corespondentă a altei tabele (cheia primară sau unică). Aceasta previne introducerea de valori inconsistente și menține integritatea datelor între tabele.",
		  "Care este rolul restricției UNIQUE și în ce situații este recomandată?": "Restricția UNIQUE impune ca toate valorile dintr-o coloană sau combinație de coloane să fie distincte. Este recomandată atunci când se dorește evitarea duplicatelor, dar nu este necesară definirea unei chei primare. Spre deosebire de PRIMARY KEY, poate exista mai multe restricții UNIQUE într-o tabelă.",
		  "Cum poate fi utilizată restricția CHECK pentru a controla validitatea valorilor?": "Restricția CHECK permite definirea unor condiții logice ce trebuie satisfăcute pentru ca o valoare să fie inserată sau actualizată într-o coloană. De exemplu, CHECK (salariu > 0) va împiedica stocarea unui salariu negativ, contribuind la integritatea la nivel de domeniu.",
		  "Ce înseamnă conceptul de NULL în SQL și ce impact are asupra operatorilor și restricțiilor?": "NULL reprezintă o valoare necunoscută sau lipsă. În SQL, NULL nu este considerat egal cu nicio valoare (inclusiv cu alt NULL), iar operatorii logici trebuie utilizați cu IS NULL sau IS NOT NULL pentru a testa prezența lui. Restricțiile precum NOT NULL pot fi folosite pentru a forța completarea coloanei.",
		  "Cum pot fi combinate operatorii de set (UNION, INTERSECT, EXCEPT) și ce reguli trebuie respectate?": "Operatorii de set combină rezultatele a două sau mai multe interogări SELECT. UNION reunește toate rândurile, eliminând duplicatele (UNION ALL le păstrează), INTERSECT returnează doar rândurile comune, iar EXCEPT (sau MINUS în unele dialecte) returnează rândurile din prima interogare care nu se regăsesc în a doua. Toate interogările trebuie să aibă același număr de coloane și tipuri de date compatibile.",
		  "Ce sunt indecșii și cum contribuie la performanța interogărilor în SQL?": "Indecșii sunt structuri auxiliare care accelerează căutările și filtrarea datelor dintr-o tabelă, similar indexului unei cărți. Ei se bazează pe coloane sau combinații de coloane, reducând timpul de scanare completă a tabelei. Totuși, folosirea excesivă a indecșilor poate afecta performanța inserărilor și actualizărilor.",
		  "Cum ajută restricțiile de integritate la menținerea corectitudinii datelor într-o bază SQL?": "Restricțiile de integritate (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) asigură consistența și corectitudinea datelor prin impunerea unor reguli stricte asupra valorilor permise. Ele previn inserarea de date invalide, relații incorecte între tabele și incoerențe logice, contribuind astfel la un model de date robust."
		},
		"Tipologia modelelor de date":
		{
		  "Ce este un model de date și care este scopul utilizării sale în SQL?": "Un model de date reprezintă o abstracție conceptuală care descrie modul în care sunt structurate, organizate și relaționate datele într-o bază de date. Scopul principal este să ofere o structură logică coerentă pentru stocarea, manipularea și accesarea datelor, facilitând proiectarea eficientă a bazelor de date și asigurând integritatea acestora.",
		  "Care sunt principalele tipuri de modele de date utilizate în SQL și care sunt caracteristicile lor?": "Cele mai importante modele de date utilizate sunt: modelul ierarhic, modelul rețea și modelul relațional. Modelul relațional este cel mai răspândit în SQL și organizează datele în tabele (relații), fiecare cu rânduri și coloane, punând accent pe integritate și normalizare. Modelul ierarhic structurează datele sub forma unui arbore, iar modelul rețea permite relații complexe de tip mulți-la-mulți.",
		  "Ce avantaje oferă modelul relațional în comparație cu alte modele de date?": "Modelul relațional este flexibil, ușor de înțeles, permite interogări complexe și asigură independența logică a datelor. De asemenea, sprijină restricțiile de integritate și permite folosirea limbajului SQL standardizat, facilitând interoperabilitatea între sisteme și un control mai bun asupra datelor.",
		  "Cum sprijină SQL implementarea modelului relațional?": "SQL a fost conceput special pentru a lucra cu modelul relațional, punând la dispoziție comenzi pentru definirea structurii (DDL), manipularea datelor (DML) și controlul accesului (DCL). Prin tabele, chei primare și străine, SQL reflectă conceptele teoretice ale modelului relațional, precum relațiile și constrângerile.",
		  "Cum se poate modela o relație de tip mulți-la-mulți în SQL și ce tip de model de date o permite?": "Relațiile mulți-la-mulți se modelează în SQL folosind o tabelă intermediară (de legătură) care conține cheile primare ale celor două tabele implicate. Această abordare este specifică modelului relațional și permite evitarea redundanțelor și respectarea integrității referențiale.",
		  "Ce este normalizarea și cum se leagă aceasta de modelul relațional?": "Normalizarea este procesul de organizare a datelor pentru a reduce redundanța și a îmbunătăți integritatea. Se bazează pe reguli formale (forme normale) care definesc modul în care se descompun tabelele. Este o componentă fundamentală a modelului relațional, contribuind la eficiența și claritatea bazei de date.",
		  "Care sunt limitările modelului relațional în SQL și cum au apărut alternative?": "Modelul relațional poate fi mai puțin performant pentru seturi mari de date ne-structurate sau foarte interconectate. De asemenea, lipsa suportului direct pentru tipuri de date complexe (ex. documente JSON) a dus la dezvoltarea modelelor NoSQL (document, graf, key-value) care oferă flexibilitate și scalabilitate mai mare pentru anumite aplicații.",
		  "Ce înseamnă modelul obiect-relațional și cum extinde modelul relațional tradițional?": "Modelul obiect-relațional combină conceptele modelului relațional cu cele orientate pe obiecte (clase, moștenire, tipuri definite de utilizator). Astfel, permite definirea de tipuri complexe, metode și structuri avansate, oferind o flexibilitate sporită în aplicații moderne, fără a renunța la structura tabelelor relaționale.",
		  "Cum pot fi reprezentate relațiile ierarhice într-o bază de date relațională?": "Relațiile ierarhice pot fi modelate folosind tabele în care fiecare rând conține o coloană care face referire la cheia primară a propriului tabel (self-referencing foreign key). Astfel se pot crea structuri de tip arbore (ex. structura angajaților într-o organizație). SQL oferă adesea funcții recursive (ex. CTE recursive) pentru a interoga astfel de ierarhii.",
		  "Cum ajută alegerea corectă a modelului de date la performanța și scalabilitatea unei aplicații?": "Alegerea unui model de date adecvat asigură optimizarea stocării, reducerea redundanței și îmbunătățirea vitezei de acces la date. Modelul relațional este excelent pentru aplicații tranzacționale și date structurate, în timp ce modele alternative (ex. graf sau document) pot fi mai eficiente pentru rețele sociale, motoare de recomandare sau aplicații big data. O alegere corectă poate reduce costurile și crește scalabilitatea aplicației."
		},
		"Moduri de organizare a datelor: fişiere, baze de date, magazii de date, depozite de date":
		{
		  "Care sunt principalele diferențe între stocarea datelor în fișiere și în baze de date?": "Stocarea în fișiere presupune păstrarea datelor în format secvențial sau structurat simplu (ex. CSV, TXT), fără mecanisme avansate de gestionare a relațiilor, integrității și concurenței. Baza de date oferă un mediu structurat, suport pentru relații complexe, interogări SQL, tranzacții și mecanisme puternice de securitate și integritate.",
		  "În ce contexte este mai eficientă utilizarea fișierelor față de bazele de date?": "Fișierele sunt eficiente pentru volume mici de date, pentru stocarea temporară, în aplicații simple sau în sisteme unde viteza de acces direct este mai importantă decât consistența datelor (ex. fișiere log, fișiere de configurare, date de backup rapide).",
		  "Ce avantaje oferă bazele de date relaționale în comparație cu fișierele tradiționale?": "Bazele de date relaționale oferă avantajul integrității referențiale, suport pentru tranzacții atomice, interogări complexe, indexare și posibilitatea de a lucra eficient cu volume mari de date structurate. De asemenea, ele permit gestionarea simultană a mai multor utilizatori și asigură consistența datelor.",
		  "Ce sunt depozitele de date (data warehouses) și cum diferă ele de bazele de date operaționale?": "Depozitele de date sunt baze de date specializate pentru analiza datelor istorice, optimizate pentru interogări complexe și rapoarte. Spre deosebire de bazele de date operaționale, care sunt proiectate pentru tranzacții curente, depozitele de date agregă și consolidează informații din surse multiple pentru a sprijini deciziile strategice.",
		  "Cum contribuie magazia de date (data mart) la organizarea eficientă a informațiilor?": "Magazia de date este o subunitate a depozitului de date, axată pe un departament sau un domeniu specific (ex. vânzări, marketing). Ea permite o analiză mai focalizată și rapidă, reducând complexitatea și resursele necesare accesării întregului depozit de date.",
		  "Care sunt principalele provocări în organizarea datelor într-un depozit de date?": "Provocările includ integrarea datelor din surse eterogene, menținerea calității și consistenței acestora, optimizarea performanței interogărilor, gestionarea volumelor mari de date și actualizarea eficientă a informațiilor fără a afecta procesele de analiză.",
		  "Ce avantaje aduc depozitele de date în analiza decizională față de bazele de date tranzacționale?": "Depozitele de date sunt optimizate pentru citire și pentru interogări analitice complexe (OLAP), permițând identificarea tendințelor, crearea de rapoarte istorice și sprijinirea deciziilor strategice. În schimb, bazele de date tranzacționale sunt optimizate pentru operațiuni de scriere și actualizare rapide (OLTP).",
		  "Cum influențează modul de organizare a datelor performanța generală a aplicațiilor?": "Organizarea adecvată a datelor influențează semnificativ performanța prin optimizarea vitezei de acces, reducerea redundanței și asigurarea scalabilității. Alegerea greșită poate duce la întârzieri, erori în rapoarte sau chiar blocaje în aplicații critice.",
		  "Ce rol joacă indexarea în bazele de date comparativ cu organizarea datelor în fișiere?": "Indexarea în baze de date accelerează căutările și filtrarea datelor, permițând acces rapid la subseturi mari. În fișiere, căutarea este de obicei secvențială, ceea ce poate fi ineficient pentru volume mari. Lipsa indexării în fișiere limitează flexibilitatea interogărilor complexe.",
		  "Cum poate fi utilizată combinarea între baze de date operaționale și depozite de date într-o organizație?": "Baza de date operațională gestionează datele curente și susține operațiunile zilnice, în timp ce depozitul de date centralizează și stochează date istorice pentru analiză și raportare. Astfel, organizația poate asigura simultan operativitate și suport decizional strategic, fără a compromite performanța niciuneia dintre cele două componente."
		},
		"Sisteme de baze de date: obiective, caracteristici, arhitecturi, componente":
		{
		  "Care sunt principalele obiective ale unui sistem de baze de date și cum contribuie acestea la eficiența organizațională?": "Obiectivele principale includ asigurarea integrității și consistenței datelor, reducerea redundanței, facilitarea accesului simultan multi-utilizator, securitatea informațiilor și suportul pentru recuperare în caz de eroare. Prin aceste obiective, sistemele de baze de date sprijină deciziile organizaționale, reduc costurile de operare și îmbunătățesc calitatea informațiilor disponibile.",
		  "Cum contribuie caracteristicile de izolare și atomicitate la integritatea tranzacțiilor într-un sistem de baze de date?": "Atomicitatea asigură că toate operațiile dintr-o tranzacție sunt executate complet sau deloc, prevenind stări intermediare invalide. Izolarea garantează că tranzacțiile concurente nu interferează între ele, menținând consistența datelor chiar și în condiții de acces simultan. Împreună, acestea protejează integritatea datelor în medii multi-utilizator.",
		  "Care sunt componentele principale ale unui sistem de baze de date și rolul fiecăreia?": "Componentele principale includ: motorul de stocare (gestionează stocarea fizică a datelor), motorul de interogare (optimizează și execută comenzile SQL), catalogul de sistem (conține metadate despre structura bazei), procesorul tranzacțiilor (asigură ACID), componentele de securitate (control acces și audit), precum și interfața pentru utilizatori și aplicații.",
		  "Ce avantaje aduce o arhitectură pe mai multe niveluri (multi-tier) într-un sistem de baze de date?": "Arhitectura multi-tier separă prezentarea, logica de afaceri și accesul la date. Această separare îmbunătățește scalabilitatea, securitatea, întreținerea și reutilizarea componentelor. De asemenea, permite distribuirea încărcării și integrarea mai ușoară cu alte sisteme sau aplicații.",
		  "Cum este implementată securitatea într-un sistem de baze de date modern?": "Securitatea include mecanisme de autentificare (verificarea identității utilizatorilor), autorizare (controlul drepturilor de acces), criptarea datelor (atât în tranzit, cât și la rest), auditarea accesului și a operațiunilor și definirea de roluri și politici detaliate de acces. Aceste măsuri previn accesul neautorizat și protejează datele sensibile.",
		  "Cum diferă arhitectura centralizată de arhitectura distribuită a bazelor de date?": "În arhitectura centralizată, toate datele sunt stocate și gestionate într-o locație unică, ceea ce simplifică administrarea, dar limitează scalabilitatea și disponibilitatea. În arhitectura distribuită, datele sunt împărțite și replicate între mai multe noduri sau locații, îmbunătățind disponibilitatea, performanța locală și toleranța la defecte, dar crescând complexitatea sincronizării și a gestionării tranzacțiilor.",
		  "Ce este un catalog de sistem (sau dicționar de date) și care este rolul său?": "Catalogul de sistem este o colecție de tabele interne care stochează metadate despre structura bazei de date: tabele, coloane, indici, privilegii, constrângeri și relații. Acesta permite motorului de baze de date și utilizatorilor să înțeleagă și să gestioneze schema bazei de date fără a consulta codul sursă direct.",
		  "Cum sprijină sistemele de baze de date suportul pentru tranzacții ACID?": "Sistemele de baze de date oferă protocoale speciale (de ex. protocolul de blocare în două faze sau journaling) pentru a implementa proprietățile ACID: Atomicitate, Consistență, Izolare și Durabilitate. Astfel, ele se asigură că datele rămân valide și corecte în fața erorilor, întreruperilor sau concurenței între utilizatori.",
		  "De ce este important controlul concurenței într-un sistem de baze de date multi-utilizator?": "Controlul concurenței asigură că tranzacțiile care rulează simultan nu duc la conflicte, anomalii sau inconsistențe. Fără un mecanism robust (precum blocarea, timestamp-urile sau versiuni multiple), operațiile concurente pot duce la probleme precum citiri murdare, pierderi de actualizare sau anomalii la citire.",
		  "Cum contribuie replicarea și clustering-ul la disponibilitatea și performanța sistemelor de baze de date?": "Replicarea implică copierea datelor pe mai multe servere pentru a asigura redundanța și disponibilitatea ridicată. Clustering-ul permite gruparea mai multor servere pentru a lucra împreună ca un singur sistem logic, îmbunătățind performanța și oferind toleranță la defecte. Astfel, sistemele pot gestiona volume mari de trafic și pot continua să funcționeze chiar dacă apar erori hardware."
		},
		"Sisteme de gestiune a bazelor de date: obiective, caracteristici, funcţii, tipologie":
		{
		  "Care sunt principalele obiective urmărite de un sistem de gestiune a bazelor de date (SGBD) modern?": "Un SGBD modern are ca obiective principale: asigurarea integrității și consistenței datelor, reducerea redundanței și a dependențelor, facilitarea accesului rapid și securizat la date, sprijinirea multi-utilizatorilor prin control al concurenței, asigurarea recuperării după incidente și crearea unui mediu flexibil și scalabil pentru dezvoltarea aplicațiilor.",
		  "Cum contribuie caracteristicile unui SGBD la asigurarea integrității și securității datelor?": "Caracteristicile esențiale precum constrângerile de integritate (chei primare, unicități, integritate referențială), controlul accesului pe bază de roluri și drepturi, jurnalizarea tranzacțiilor (logging), criptarea datelor și auditarea activităților utilizatorilor asigură protecția datelor împotriva coruperii și accesului neautorizat.",
		  "Ce rol joacă funcțiile de control al concurenței într-un SGBD și cum sunt acestea implementate?": "Funcțiile de control al concurenței previn conflictele generate de accesul simultan la aceleași date de către mai mulți utilizatori. Acestea sunt implementate prin tehnici de blocare (locking), timestamp-uri, versiuni multiple ale datelor (MVCC) și protocoale de izolare, asigurând execuția corectă și izolată a tranzacțiilor.",
		  "Care sunt funcțiile principale ale unui SGBD și cum sprijină acestea utilizatorii?": "Funcțiile principale includ: definirea și manipularea datelor (prin limbajele DDL și DML), gestionarea stocării și indexării, controlul tranzacțiilor, controlul accesului și securității, suport pentru backup și recuperare, precum și facilitarea interfețelor pentru aplicații și raportare. Aceste funcții permit utilizatorilor să acceseze, să modifice și să administreze datele într-un mod sigur și eficient.",
		  "Cum influențează tipologia SGBD-urilor alegerea soluției pentru o organizație?": "Tipologia SGBD-urilor (relaționale, orientate pe obiecte, NoSQL, hibride, distribuite) determină modul de modelare a datelor, performanța, scalabilitatea și costurile. Alegerea se face în funcție de volumul de date, tipul de aplicații, necesitatea relațiilor complexe, viteza de acces și flexibilitatea în structura datelor.",
		  "Care sunt avantajele și dezavantajele utilizării unui SGBD relațional comparativ cu un SGBD NoSQL?": "SGBD-urile relaționale oferă suport solid pentru integritatea datelor, relații complexe și tranzacții ACID, fiind ideale pentru aplicații tradiționale (ERP, contabilitate). NoSQL excelează la scalabilitate orizontală, flexibilitate în stocarea datelor nestructurate și performanță în aplicații web sau big data. Dezavantajele includ rigiditatea modelului relațional și lipsa tranzacțiilor ACID complete în multe soluții NoSQL.",
		  "Cum sprijină un SGBD gestionarea eficientă a volumelor mari de date?": "Un SGBD gestionează volume mari de date prin mecanisme precum partiționarea tabelelor, indexarea avansată, optimizarea interogărilor, compresia datelor, replicarea și distribuirea pe mai multe noduri. Astfel, performanța interogărilor este menținută chiar și la creșterea masivă a volumului de date.",
		  "Ce provocări ridică migrarea datelor între două sisteme de gestiune a bazelor de date diferite?": "Migrarea implică provocări precum diferențele în modelul de date și sintaxa SQL, incompatibilități la nivel de tipuri de date, transferul integrității referențiale și al constrângerilor, migrarea procedurilor stocate și a funcțiilor definite de utilizator, precum și menținerea consistenței și minimizarea timpilor de nefuncționare.",
		  "Cum poate un SGBD să sprijine dezvoltarea rapidă a aplicațiilor moderne (ex. microservicii, aplicații web scalabile)?": "Prin expunerea de API-uri standard (ex. REST, GraphQL), suport pentru JSON sau XML, integrarea cu cache distribuie și funcții avansate de replicare, SGBD-urile moderne permit dezvoltatorilor să construiască aplicații scalabile și reactive rapid. De asemenea, suportul pentru containere și orchestrare (Kubernetes) facilitează integrarea în arhitecturi moderne de microservicii.",
		  "Ce caracteristici definesc un SGBD distribuit și în ce scenarii este acesta preferat?": "Un SGBD distribuit se caracterizează prin stocarea și procesarea datelor pe mai multe servere/noduri, oferind redundanță, disponibilitate ridicată și scalabilitate orizontală. Este preferat în aplicații care trebuie să deservească utilizatori globali, să gestioneze volume mari de date în timp real și să reziste la defecte hardware fără oprirea serviciului."
		},
		"Modelul relaţional: structura relaţională a datelor, algebra şi calculul relaţional, restricţii de integritate. Exemplificări în Oracle":
		{
			"Fie tabela: cities (id, name, district, inhabitants). Scrieți interogarea care afișează orașele din județe cu cel puțin 500.000 de locuitori.": "SELECT * FROM cities WHERE district IN (SELECT district FROM cities GROUP BY district HAVING SUM(inhabitants) >= 500000);",
			"Fie tabelele: products (id, name), order_items (id, order_id, product_id, quantity, price). Scrieți interogarea care selectează numele produselor și valoarea vânzărilor pentru cele mai bine vândute 10 produse.": "SELECT p.name, SUM(oi.quantity * oi.price) AS total_sales FROM products p JOIN order_items oi ON p.id = oi.product_id GROUP BY p.id, p.name ORDER BY total_sales DESC LIMIT 10;",
			"Fie tabelele: products (id, name), order_items (id, order_id, product_id, quantity, price). Scrieți interogarea care selectează numele fiecărui produs și valoarea vânzărilor pentru produsul respectiv, ordonate crescător după numele produsului.": "SELECT p.name, SUM(oi.quantity * oi.price) AS total_sales FROM products p JOIN order_items oi ON p.id = oi.product_id GROUP BY p.id, p.name ORDER BY p.name ASC;",
			"Fie tabelele: products (id, name), order_items (id, order_id, product_id, quantity, price). Scrieți interogarea care afișează toate produsele care nu au vânzări, ordonate crescător după numele produsului.": "SELECT p.name FROM products p LEFT JOIN order_items oi ON p.id = oi.product_id WHERE oi.id IS NULL ORDER BY p.name ASC;",
			"Fie tabela: cities (id, name, district, inhabitants). Scrieți interogarea care afișează județele și numărul de locuitori din fiecare județ, pentru județele al căror nume începe cu 'A'.": "SELECT district, SUM(inhabitants) AS total_inhabitants FROM cities WHERE district LIKE 'A%' GROUP BY district;",
			"Fie tabela: cities (id, name, district, inhabitants). Scrieți interogarea care afișează numărul de orașe pentru fiecare județ și numele județului, ordonate descrescător după numărul de orașe.": "SELECT district, COUNT(*) AS numar_orase FROM cities GROUP BY district ORDER BY numar_orase DESC;",
			"Fie tabela: cities (id, name, district, inhabitants). Scrieți interogarea care afișează județele care au orașe cu același nume.": "SELECT DISTINCT district FROM cities GROUP BY district, name HAVING COUNT(*) >= 2;",
			"Fie tabelele: agents (id, name), products (id, name), orders (id, agent_id, date), order_items (id, order_id, product_id, quantity, price). Scrieți interogarea care afișează primii 10 agenți după valoarea vânzărilor, împreună cu valoarea vânzărilor, sortați descrescător după valoarea vânzărilor.": "SELECT a.name AS agent_name, SUM(oi.quantity * oi.price) AS total_sales FROM agents a JOIN orders o ON a.id = o.agent_id JOIN order_items oi ON o.id = oi.order_id GROUP BY a.id, a.name ORDER BY total_sales DESC LIMIT 10;",
			"Fie tabelele: agents (id, name), products (id, name), orders (id, agent_id, date), order_items (id, order_id, product_id, quantity, price). Scrieți interogarea care afișează agenții care nu au realizat vânzări.": "SELECT a.name FROM agents a LEFT JOIN orders o ON a.id = o.agent_id LEFT JOIN order_items oi ON o.id = oi.order_id WHERE oi.id IS NULL;",
			"Fie tabela: cities (id, name, district, inhabitants). Scrieți interogarea care afișează orașele cu populație mai mare decât media populației orașelor, ordonate descrescător după numărul de locuitori.": "SELECT name, inhabitants FROM cities WHERE inhabitants > (SELECT AVG(inhabitants) FROM cities) ORDER BY inhabitants DESC;"
		} 
		
	}
}